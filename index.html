<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìˆ˜ì–´ í•™ìŠµ ë° ì¸ì‹ ì‹œìŠ¤í…œ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 20px);
        }

        .camera-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .data-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn.secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .recognition-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .current-sign {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .confidence {
            font-size: 16px;
            opacity: 0.8;
        }

        .training-section {
            background: rgba(255, 152, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }

        .training-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .word-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: white;
            font-size: 14px;
            flex: 1;
        }

        .word-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .recording-indicator {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .trained-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .trained-word-item {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid rgba(255, 152, 0, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cloud-indicator {
            background: rgba(76, 175, 80, 0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .recognized-words-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .recognized-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            min-height: 100px;
        }

        .word-item {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .word-text {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
        }

        .word-time {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .remove-btn {
            background: rgba(244, 67, 54, 0.6);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .remove-btn:hover {
            background: rgba(244, 67, 54, 0.8);
        }

        .empty-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            margin: 20px 0;
        }

        .text-output {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 40px 20px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Arial', sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: #00ff00;
            border: 2px solid rgba(0, 255, 0, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .status.ready {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .status.recording {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }

        .status.cloud {
            background: rgba(156, 39, 176, 0.2);
            color: #9C27B0;
        }

        .recording-progress {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .recording-progress-bar {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        h3 {
            margin-bottom: 15px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="camera-section">
            <h2>ğŸ¥ ìˆ˜ì–´ í•™ìŠµ ë° ì¸ì‹</h2>
            
            <div id="status" class="status">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>
            
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="canvasOverlay" class="canvas-overlay"></canvas>
            </div>
            
            <div class="controls">
                <button id="startBtn" class="btn" onclick="startDetection()">ì¹´ë©”ë¼ ì‹œì‘</button>
                <button id="recognitionBtn" class="btn secondary" onclick="toggleRecognition()" disabled>ì¸ì‹ ëª¨ë“œ</button>
            </div>
            
            <div class="recognition-display">
                <div class="current-sign" id="currentSign">ëŒ€ê¸° ì¤‘...</div>
                <div class="confidence" id="confidence">ì‹ ë¢°ë„: 0%</div>
            </div>
        </div>

        <div class="data-section">
            <div class="training-section">
                <h3>ğŸ“š ìˆ˜ì–´ ë°ì´í„° ìˆ˜ì§‘ (í•™ìŠµ)</h3>
                
                <div class="training-controls">
                    <input type="text" id="wordInput" class="word-input" placeholder="í•™ìŠµí•  ìˆ˜ì–´ ë‹¨ì–´ ì…ë ¥ (ì˜ˆ: ì•ˆë…•í•˜ì„¸ìš”)">
                    <button id="recordBtn" class="btn danger" onclick="toggleRecording()" disabled>ë…¹í™” ì‹œì‘</button>
                </div>
                
                <div class="recording-progress">
                    <div class="recording-progress-bar" id="progressBar"></div>
                </div>
                
                <div id="trainedWordsList" class="trained-words-list">
                    <div class="empty-message">í´ë¼ìš°ë“œì—ì„œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
                </div>
            </div>
            
            <div class="recognized-words-section">
                <h3>ğŸ’¬ ì¸ì‹ëœ ë‹¨ì–´</h3>
                <button class="btn danger" onclick="clearRecognizedWords()" style="margin-bottom: 10px;">ì¸ì‹ ê¸°ë¡ ì§€ìš°ê¸°</button>
                <div class="recognized-words-list" id="recognizedWordsList">
                    <div class="empty-message">ì¸ì‹ëœ ë‹¨ì–´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
                </div>
            </div>
            
            <div class="text-output" id="textOutput">
                <div id="currentText" style="color: #888;">
                    ìˆ˜ì–´ë¥¼ í•™ìŠµì‹œí‚¨ í›„ ì¸ì‹ ëª¨ë“œì—ì„œ<br>
                    ì‹¤ì‹œê°„ ì¸ì‹ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤
                </div>
            </div>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://qmddevysfschoeairtjg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFtZGRldnlzZnNjaG9lYWlydGpnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg5OTM3NzAsImV4cCI6MjA3NDU2OTc3MH0.aGrQq1-VPSEv3yXUjpDlk_LkEarq3ZwCY86JKIhFW5s';
        
        let supabase;
        let isSupabaseEnabled = false;

        function initializeSupabase() {
            try {
                if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                    console.warn('Supabase ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¡œì»¬ ì €ì¥ì†Œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                    isSupabaseEnabled = false;
                    return false;
                }
                
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isSupabaseEnabled = true;
                console.log('Supabase ì—°ê²° ì„±ê³µ');
                return true;
            } catch (error) {
                console.error('Supabase ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                isSupabaseEnabled = false;
                return false;
            }
        }

        async function saveToCloudAuto(word, signData, videoBlob = null) {
            if (!isSupabaseEnabled) return false;

            try {
                let videoUrl = null;
                
                // ë¹„ë””ì˜¤ê°€ ìˆìœ¼ë©´ Storageì— ì—…ë¡œë“œ
                if (videoBlob) {
                    const fileName = `${word}_${Date.now()}.webm`;
                    const { data: uploadData, error: uploadError } = await supabase
                        .storage
                        .from('sign-videos')
                        .upload(fileName, videoBlob, {
                            contentType: 'video/webm',
                            upsert: false
                        });

                    if (uploadError) {
                        console.error('ë¹„ë””ì˜¤ ì—…ë¡œë“œ ì‹¤íŒ¨:', uploadError);
                    } else {
                        // Public URL ê°€ì ¸ì˜¤ê¸°
                        const { data: urlData } = supabase
                            .storage
                            .from('sign-videos')
                            .getPublicUrl(fileName);
                        videoUrl = urlData.publicUrl;
                        console.log('ë¹„ë””ì˜¤ ì—…ë¡œë“œ ì™„ë£Œ:', videoUrl);
                    }
                }

                const dataToSave = {
                    word: word,
                    features: JSON.stringify(signData.features),
                    timestamp: new Date(signData.timestamp).toISOString(),
                    video_url: videoUrl
                };

                const { data: existing } = await supabase
                    .from('sign_language_data')
                    .select('id')
                    .eq('word', word)
                    .single();

                let result;
                if (existing) {
                    result = await supabase
                        .from('sign_language_data')
                        .update(dataToSave)
                        .eq('word', word);
                } else {
                    result = await supabase
                        .from('sign_language_data')
                        .insert([dataToSave]);
                }

                if (result.error) {
                    throw result.error;
                }

                console.log(`"${word}" í´ë¼ìš°ë“œ ì €ì¥ ì™„ë£Œ${videoUrl ? ' (ë¹„ë””ì˜¤ í¬í•¨)' : ''}`);
                return true;

            } catch (error) {
                console.error('í´ë¼ìš°ë“œ ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
                return false;
            }
        }

        async function loadFromCloudAuto() {
            if (!isSupabaseEnabled) {
                loadFromLocalStorage();
                return;
            }

            try {
                const { data, error } = await supabase
                    .from('sign_language_data')
                    .select('*')
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('í´ë¼ìš°ë“œ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                    loadFromLocalStorage();
                    return;
                }

                if (!data || data.length === 0) {
                    console.log('í´ë¼ìš°ë“œì— ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŒ');
                    loadFromLocalStorage();
                    return;
                }

                trainedSigns = {};
                data.forEach(item => {
                    trainedSigns[item.word] = {
                        features: JSON.parse(item.features),
                        timestamp: new Date(item.created_at).getTime(),
                        fromCloud: true
                    };
                });

                updateTrainedWordsList();
                console.log(`${data.length}ê°œ ìˆ˜ì–´ í´ë¼ìš°ë“œì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ`);

                saveToLocalStorage();

            } catch (error) {
                console.error('í´ë¼ìš°ë“œ ìë™ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                loadFromLocalStorage();
            }
        }

        async function removeFromCloud(word) {
            if (!isSupabaseEnabled) return;

            try {
                const { error } = await supabase
                    .from('sign_language_data')
                    .delete()
                    .eq('word', word);

                if (error) {
                    console.error('í´ë¼ìš°ë“œ ì‚­ì œ ì‹¤íŒ¨:', error);
                } else {
                    console.log(`"${word}" í´ë¼ìš°ë“œì—ì„œ ì‚­ì œ ì™„ë£Œ`);
                }
            } catch (error) {
                console.error('í´ë¼ìš°ë“œ ì‚­ì œ ì‹¤íŒ¨:', error);
            }
        }

        let hands;
        let isDetecting = false;
        let isRecording = false;
        let isRecognizing = false;
        let trainedSigns = {};
        let recognizedWords = [];
        let currentRecording = null;
        let recordingInterval = null;
        let mediaRecorder = null;
        let recordedChunks = [];

        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 0,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);
        }

        // ìˆ˜ì •ëœ íŠ¹ì§• ì¶”ì¶œ í•¨ìˆ˜
        function extractFeatures(landmarks) {
            if (!landmarks || landmarks.length === 0) return null;
            
            const features = [];
            let firstWrist = null;
            
            landmarks.forEach((hand, handIndex) => {
                const wrist = hand[0];
                if (handIndex === 0) firstWrist = wrist;
                
                const normalizedHand = hand.map(point => ({
                    x: point.x - wrist.x,
                    y: point.y - wrist.y,
                    z: point.z - wrist.z
                }));
                
                // 1. ê¸°ë³¸ ì¢Œí‘œ
                for (let i = 0; i < normalizedHand.length; i++) {
                    features.push(normalizedHand[i].x, normalizedHand[i].y, normalizedHand[i].z);
                }
                
                // 2. ì†ê°€ë½ ë ê°„ ê±°ë¦¬
                const fingerTips = [4, 8, 12, 16, 20];
                for (let i = 0; i < fingerTips.length; i++) {
                    for (let j = i + 1; j < fingerTips.length; j++) {
                        const p1 = normalizedHand[fingerTips[i]];
                        const p2 = normalizedHand[fingerTips[j]];
                        const distance = Math.sqrt(
                            Math.pow(p1.x - p2.x, 2) + 
                            Math.pow(p1.y - p2.y, 2) + 
                            Math.pow(p1.z - p2.z, 2)
                        );
                        features.push(distance);
                    }
                }
                
                // 3. ì†ê°€ë½ êµ½í˜ ê°ë„
                const fingerJoints = [
                    [0, 1, 2, 3, 4],
                    [0, 5, 6, 7, 8],
                    [0, 9, 10, 11, 12],
                    [0, 13, 14, 15, 16],
                    [0, 17, 18, 19, 20]
                ];
                
                fingerJoints.forEach(joints => {
                    for (let i = 0; i < joints.length - 2; i++) {
                        const p1 = normalizedHand[joints[i]];
                        const p2 = normalizedHand[joints[i + 1]];
                        const p3 = normalizedHand[joints[i + 2]];
                        
                        const v1 = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
                        const v2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: p3.z - p2.z };
                        
                        const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
                        const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
                        const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
                        
                        const angle = len1 > 0 && len2 > 0 ? dot / (len1 * len2) : 0;
                        features.push(angle);
                    }
                });

                // 4. ì†ë°”ë‹¥ í¬ê¸°
                const palmSize = Math.sqrt(
                    Math.pow(normalizedHand[5].x - normalizedHand[17].x, 2) +
                    Math.pow(normalizedHand[5].y - normalizedHand[17].y, 2)
                );
                features.push(palmSize);
                
                // 5. ê° ì†ê°€ë½ í¼ì¹¨ ì •ë„
                fingerTips.forEach(tip => {
                    const distance = Math.sqrt(
                        Math.pow(normalizedHand[tip].x, 2) +
                        Math.pow(normalizedHand[tip].y, 2) +
                        Math.pow(normalizedHand[tip].z, 2)
                    );
                    features.push(distance);
                });
            });

            // ì²« ë²ˆì§¸ ì†ì˜ ì†ëª© ìœ„ì¹˜ ì¶”ê°€
            if (firstWrist) {
                features.push(firstWrist.x, firstWrist.y, firstWrist.z);
            }
            
            return features;
        }

        function calculateSimilarity(features1, features2) {
            if (!features1 || !features2) return 0;
            if (features1.length !== features2.length) return 0;
            
            let dotProduct = 0;
            let norm1 = 0;
            let norm2 = 0;
            
            for (let i = 0; i < features1.length; i++) {
                dotProduct += features1[i] * features2[i];
                norm1 += features1[i] * features1[i];
                norm2 += features2[i] * features2[i];
            }
            
            norm1 = Math.sqrt(norm1);
            norm2 = Math.sqrt(norm2);
            
            if (norm1 === 0 || norm2 === 0) return 0;
            
            return dotProduct / (norm1 * norm2);
        }

        function dtw(seq1, seq2) {
            const n = seq1.length;
            const m = seq2.length;
            const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
            
            dtw[0][0] = 0;
            
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    const cost = 1 - calculateSimilarity(seq1[i - 1], seq2[j - 1]);
                    dtw[i][j] = cost + Math.min(
                        dtw[i - 1][j],
                        dtw[i][j - 1],
                        dtw[i - 1][j - 1]
                    );
                }
            }
            
            return dtw[n][m] / Math.max(n, m);
        }

        function recognizeSign(currentFeatures) {
            let bestMatch = null;
            let bestSimilarity = 0;
            const threshold = 0.65;
            const minFrames = 15;
            
            if (recentFrames.length < minFrames) {
                return null;
            }
            
            for (const [word, signData] of Object.entries(trainedSigns)) {
                if (!signData.features || signData.features.length < minFrames) {
                    continue;
                }
                
                const dtwDistance = dtw(
                    recentFrames.slice(-25),
                    signData.features
                );
                
                const similarity = Math.max(0, 1 - dtwDistance);
                
                if (similarity > bestSimilarity) {
                    bestSimilarity = similarity;
                    bestMatch = word;
                }
            }
            
            if (bestSimilarity > threshold) {
                let secondBestSimilarity = 0;
                for (const [word, signData] of Object.entries(trainedSigns)) {
                    if (word === bestMatch) continue;
                    if (!signData.features || signData.features.length < minFrames) {
                        continue;
                    }
                    
                    const dtwDistance = dtw(
                        recentFrames.slice(-25),
                        signData.features
                    );
                    const similarity = Math.max(0, 1 - dtwDistance);
                    
                    if (similarity > secondBestSimilarity) {
                        secondBestSimilarity = similarity;
                    }
                }
                
                const confidenceGap = bestSimilarity - secondBestSimilarity;
                if (confidenceGap < 0.05) {
                    console.log(`ë¶ˆí™•ì‹¤í•œ ì¸ì‹: ${bestMatch} (ì°¨ì´: ${(confidenceGap * 100).toFixed(1)}%)`);
                    return { word: bestMatch, confidence: bestSimilarity };
                }
                
                return { word: bestMatch, confidence: bestSimilarity };
            }
            
            return null;
        }

        let recentFrames = [];
        const MAX_FRAMES = 40;
        let lastProcessTime = 0;
        const PROCESS_INTERVAL = 300;
        const MIN_CONFIDENCE_THRESHOLD = 0.65;
        const MIN_RECOGNITION_FRAMES = 15;

        function onHandsResults(results) {
            drawHandLandmarks(results);
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if (!isRecording) {
                    document.getElementById('currentSign').textContent = 'ì†ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ';
                    document.getElementById('confidence').textContent = 'ì‹ ë¢°ë„: 0%';
                }
                if (isRecognizing && recentFrames.length > 0) {
                    recentFrames = [];
                }
                return;
            }
            
            const features = extractFeatures(results.multiHandLandmarks);
            
            if (!features) {
                return;
            }
            
            if (isRecording && currentRecording) {
                currentRecording.features.push(features);
                currentRecording.landmarks.push(results.multiHandLandmarks);
            }
            
            if (isRecognizing && !isRecording) {
                const now = Date.now();
                if (now - lastProcessTime < PROCESS_INTERVAL) {
                    return;
                }
                lastProcessTime = now;

                recentFrames.push(features);
                if (recentFrames.length > MAX_FRAMES) {
                    recentFrames.shift();
                }
                
                if (recentFrames.length >= MIN_RECOGNITION_FRAMES) {
                    const recognition = recognizeSign(features);
                    
                    if (recognition && recognition.confidence >= MIN_CONFIDENCE_THRESHOLD) {
                        document.getElementById('currentSign').textContent = recognition.word;
                        document.getElementById('confidence').textContent = 
                            `ì‹ ë¢°ë„: ${Math.round(recognition.confidence * 100)}%`;
                        
                        addRecognizedWord(recognition.word);
                        
                        document.getElementById('currentText').textContent = recognition.word;
                        document.getElementById('currentText').style.color = '#00ff00';
                    } else {
                        document.getElementById('currentSign').textContent = 'ì¸ì‹ ì¤‘...';
                        document.getElementById('confidence').textContent = 
                            recognition ? `ì‹ ë¢°ë„: ${Math.round(recognition.confidence * 100)}% (ë‚®ìŒ)` : 'ì‹ ë¢°ë„: ë‚®ìŒ';
                    }
                } else {
                    document.getElementById('currentSign').textContent = 'ì†ë™ì‘ ìˆ˜ì§‘ ì¤‘...';
                    document.getElementById('confidence').textContent = `í”„ë ˆì„: ${recentFrames.length}/${MIN_RECOGNITION_FRAMES}`;
                }
            }
        }

        function drawHandLandmarks(results) {
            const canvas = document.getElementById('canvasOverlay');
            const video = document.getElementById('videoElement');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth || video.offsetWidth;
            canvas.height = video.videoHeight || video.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handColor = index === 0 ? '#00ff00' : '#ff6600';
                    
                    ctx.strokeStyle = handColor;
                    ctx.lineWidth = 2;
                    
                    const connections = [
                        [0,1],[1,2],[2,3],[3,4],
                        [0,5],[5,6],[6,7],[7,8],
                        [0,9],[9,10],[10,11],[11,12],
                        [0,13],[13,14],[14,15],[15,16],
                        [0,17],[17,18],[18,19],[19,20],
                        [5,9],[9,13],[13,17]
                    ];
                    
                    connections.forEach(([start, end]) => {
                        const startPoint = landmarks[start];
                        const endPoint = landmarks[end];
                        
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
                        ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
                        ctx.stroke();
                    });
                    
                    landmarks.forEach(point => {
                        const x = point.x * canvas.width;
                        const y = point.y * canvas.height;
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = handColor;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const video = document.getElementById('videoElement');
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve);
                    };
                });
                
                return true;
            } catch (error) {
                console.error('ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:', error);
                document.getElementById('status').textContent = 'ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨';
                document.getElementById('status').className = 'status error';
                return false;
            }
        }

        async function startDetection() {
            const startBtn = document.getElementById('startBtn');
            const recordBtn = document.getElementById('recordBtn');
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (!isDetecting) {
                const cameraReady = await startCamera();
                if (cameraReady) {
                    const video = document.getElementById('videoElement');
                    
                    const processFrame = async () => {
                        if (isDetecting && video.readyState >= 2) {
                            await hands.send({ image: video });
                        }
                        if (isDetecting) {
                            requestAnimationFrame(processFrame);
                        }
                    };
                    
                    isDetecting = true;
                    startBtn.textContent = 'ì¹´ë©”ë¼ ì¤‘ì§€';
                    startBtn.classList.add('danger');
                    recordBtn.disabled = false;
                    recognitionBtn.disabled = false;
                    status.textContent = 'ì¤€ë¹„ ì™„ë£Œ';
                    status.className = 'status ready';
                    
                    processFrame();
                }
            } else {
                isDetecting = false;
                isRecognizing = false;
                startBtn.textContent = 'ì¹´ë©”ë¼ ì‹œì‘';
                startBtn.classList.remove('danger');
                recordBtn.disabled = true;
                recognitionBtn.disabled = true;
                recognitionBtn.textContent = 'ì¸ì‹ ëª¨ë“œ';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'ì¹´ë©”ë¼ ì¤‘ì§€ë¨';
                status.className = 'status';
                
                const video = document.getElementById('videoElement');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
            }
        }

        function toggleRecording() {
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            if (!isRecording) {
                const word = wordInput.value.trim();
                if (!word) {
                    alert('í•™ìŠµí•  ìˆ˜ì–´ ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
                    return;
                }
                
                isRecording = true;
                recordedChunks = [];
                
                // MediaRecorderë¡œ ë¹„ë””ì˜¤ ë…¹í™” ì‹œì‘
                const video = document.getElementById('videoElement');
                const stream = video.srcObject;
                
                try {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp8,opus'
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.start();
                } catch (error) {
                    console.error('MediaRecorder ì‹œì‘ ì‹¤íŒ¨:', error);
                }
                
                currentRecording = {
                    word: word,
                    features: [],
                    landmarks: [],
                    startTime: Date.now()
                };
                
                recordBtn.textContent = 'ë…¹í™” ì¤‘ì§€ (5ì´ˆ)';
                recordBtn.classList.add('recording-indicator');
                status.textContent = `"${word}" ë…¹í™” ì¤‘...`;
                status.className = 'status recording';
                wordInput.disabled = true;
                
                let progress = 0;
                recordingInterval = setInterval(() => {
                    progress += 10;
                    progressBar.style.width = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(recordingInterval);
                        stopRecording();
                    }
                }, 250);
                
            } else {
                stopRecording();
            }
        }

        async function stopRecording() {
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
            
            // MediaRecorder ì¤‘ì§€
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            isRecording = false;
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            recordBtn.textContent = 'ë…¹í™” ì‹œì‘';
            recordBtn.classList.remove('recording-indicator');
            wordInput.disabled = false;
            progressBar.style.width = '0%';
            
            if (currentRecording && currentRecording.features.length > 0) {
                status.textContent = 'ë¹„ë””ì˜¤ ì²˜ë¦¬ ì¤‘...';
                status.className = 'status cloud';
                
                // ë¹„ë””ì˜¤ Blob ìƒì„± (MediaRecorderê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°)
                await new Promise(resolve => setTimeout(resolve, 500));
                
                let videoBlob = null;
                if (recordedChunks.length > 0) {
                    videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    console.log(`ë¹„ë””ì˜¤ í¬ê¸°: ${(videoBlob.size / 1024 / 1024).toFixed(2)} MB`);
                }
                
                const signData = {
                    features: currentRecording.features,
                    landmarks: currentRecording.landmarks,
                    timestamp: Date.now(),
                    fromCloud: false
                };
                
                trainedSigns[currentRecording.word] = signData;
                
                saveToLocalStorage();
                
                // ë¹„ë””ì˜¤ì™€ í•¨ê»˜ í´ë¼ìš°ë“œì— ì €ì¥
                const cloudSaved = await saveToCloudAuto(currentRecording.word, signData, videoBlob);
                
                if (cloudSaved) {
                    trainedSigns[currentRecording.word].fromCloud = true;
                    status.textContent = `"${currentRecording.word}" í•™ìŠµ ì™„ë£Œ! (í´ë¼ìš°ë“œ ì €ì¥ë¨${videoBlob ? ' + ë¹„ë””ì˜¤' : ''})`;
                    status.className = 'status cloud';
                } else {
                    status.textContent = `"${currentRecording.word}" í•™ìŠµ ì™„ë£Œ! (ë¡œì»¬ ì €ì¥ë¨)`;
                    status.className = 'status ready';
                }
                
                updateTrainedWordsList();
                
                wordInput.value = '';
            } else {
                status.textContent = 'ë…¹í™” ì‹¤íŒ¨ - ì†ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ';
                status.className = 'status error';
            }
            
            currentRecording = null;
            recordedChunks = [];
        }

        function toggleRecognition() {
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (Object.keys(trainedSigns).length === 0) {
                alert('ë¨¼ì € ìˆ˜ì–´ë¥¼ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            isRecognizing = !isRecognizing;
            
            if (isRecognizing) {
                recognitionBtn.textContent = 'ì¸ì‹ ì¤‘ì§€';
                recognitionBtn.classList.add('danger');
                status.textContent = 'ì¸ì‹ ëª¨ë“œ í™œì„±í™”';
                status.className = 'status ready';
                recentFrames = [];
            } else {
                recognitionBtn.textContent = 'ì¸ì‹ ëª¨ë“œ';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'ì¸ì‹ ëª¨ë“œ ë¹„í™œì„±í™”';
                status.className = 'status';
                document.getElementById('currentSign').textContent = 'ëŒ€ê¸° ì¤‘...';
                document.getElementById('confidence').textContent = 'ì‹ ë¢°ë„: 0%';
            }
        }

        function updateTrainedWordsList() {
            const listElement = document.getElementById('trainedWordsList');
            const words = Object.keys(trainedSigns);
            
            if (words.length === 0) {
                listElement.innerHTML = '<div class="empty-message">í•™ìŠµëœ ìˆ˜ì–´ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }
            
            listElement.innerHTML = '';
            words.forEach(word => {
                const item = document.createElement('div');
                item.className = 'trained-word-item';
                const isFromCloud = trainedSigns[word].fromCloud;
                item.innerHTML = `
                    <span>${word}${isFromCloud ? '<span class="cloud-indicator">â˜ï¸</span>' : ''}</span>
                    <button class="remove-btn" onclick="removeTrainedWord('${word}')">ì‚­ì œ</button>
                `;
                listElement.appendChild(item);
            });
        }

        async function removeTrainedWord(word) {
            if (confirm(`"${word}" ìˆ˜ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                const wasFromCloud = trainedSigns[word].fromCloud;
                
                delete trainedSigns[word];
                updateTrainedWordsList();
                saveToLocalStorage();
                
                if (wasFromCloud) {
                    await removeFromCloud(word);
                }
            }
        }

        let lastRecognizedWord = '';
        let lastRecognizedTime = 0;
        const RECOGNITION_COOLDOWN = 2000;
        
        function addRecognizedWord(word) {
            const now = Date.now();
            
            if (word === lastRecognizedWord && (now - lastRecognizedTime) < RECOGNITION_COOLDOWN) {
                return;
            }
            
            lastRecognizedWord = word;
            lastRecognizedTime = now;
            
            const wordData = {
                text: word,
                timestamp: new Date(),
                id: Date.now()
            };
            
            recognizedWords.push(wordData);
            updateRecognizedWordsList();
        }

        function updateRecognizedWordsList() {
            const listElement = document.getElementById('recognizedWordsList');
            
            if (recognizedWords.length === 0) {
                listElement.innerHTML = '<div class="empty-message">ì¸ì‹ëœ ë‹¨ì–´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>';
                return;
            }
            
            listElement.innerHTML = '';
            
            recognizedWords.slice().reverse().forEach(wordData => {
                const item = document.createElement('div');
                item.className = 'word-item';
                item.innerHTML = `
                    <div>
                        <div class="word-text">${wordData.text}</div>
                        <div class="word-time">${formatTime(wordData.timestamp)}</div>
                    </div>
                    <button class="remove-btn" onclick="removeRecognizedWord(${wordData.id})">ì‚­ì œ</button>
                `;
                listElement.appendChild(item);
            });
        }

        function removeRecognizedWord(id) {
            recognizedWords = recognizedWords.filter(word => word.id !== id);
            updateRecognizedWordsList();
        }

        function clearRecognizedWords() {
            if (recognizedWords.length === 0) return;
            
            if (confirm('ëª¨ë“  ì¸ì‹ ê¸°ë¡ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                recognizedWords = [];
                updateRecognizedWordsList();
                document.getElementById('currentText').textContent = 'ìˆ˜ì–´ë¥¼ í•™ìŠµì‹œí‚¨ í›„ ì¸ì‹ ëª¨ë“œì—ì„œ\nì‹¤ì‹œê°„ ì¸ì‹ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤';
                document.getElementById('currentText').style.color = '#888';
            }
        }

        function formatTime(timestamp) {
            const now = new Date();
            const time = new Date(timestamp);
            const diff = now - time;
            
            if (diff < 60000) {
                return 'ë°©ê¸ˆ ì „';
            } else if (diff < 3600000) {
                return `${Math.floor(diff / 60000)}ë¶„ ì „`;
            } else {
                return time.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
            }
        }

        function saveToLocalStorage() {
            try {
                const data = {
                    trainedSigns: {},
                    savedAt: Date.now()
                };
                
                for (const [word, signData] of Object.entries(trainedSigns)) {
                    data.trainedSigns[word] = {
                        features: signData.features,
                        timestamp: signData.timestamp,
                        fromCloud: signData.fromCloud || false
                    };
                }
                
                localStorage.setItem('signLanguageData', JSON.stringify(data));
                console.log('ë¡œì»¬ ì €ì¥ ì™„ë£Œ');
            } catch (error) {
                console.error('ë¡œì»¬ ì €ì¥ ì˜¤ë¥˜:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('signLanguageData');
                if (saved) {
                    const data = JSON.parse(saved);
                    trainedSigns = data.trainedSigns || {};
                    updateTrainedWordsList();
                    console.log(`${Object.keys(trainedSigns).length}ê°œì˜ ìˆ˜ì–´ë¥¼ ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤`);
                }
            } catch (error) {
                console.error('ë¡œì»¬ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
            }
        }

        window.addEventListener('load', async () => {
            console.log('ìˆ˜ì–´ í•™ìŠµ ë° ì¸ì‹ ì‹œìŠ¤í…œ ì´ˆê¸°í™”');
            
            const status = document.getElementById('status');
            status.textContent = 'Supabase ì—°ê²° ì¤‘...';
            status.className = 'status cloud';
            
            initializeSupabase();
            
            setTimeout(async () => {
                if (typeof Hands !== 'undefined') {
                    initializeHands();
                    
                    await loadFromCloudAuto();
                    
                    status.textContent = isSupabaseEnabled ? 
                        'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ (í´ë¼ìš°ë“œ ì—°ê²°ë¨)' : 
                        'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ (ë¡œì»¬ ëª¨ë“œ)';
                    status.className = 'status ready';
                } else {
                    status.textContent = 'MediaPipe ë¡œë”© ì‹¤íŒ¨';
                    status.className = 'status error';
                }
            }, 2000);
        });

        window.addEventListener('beforeunload', () => {
            if (Object.keys(trainedSigns).length > 0) {
                saveToLocalStorage();
            }
        });
    </script>
</body>
</html>
