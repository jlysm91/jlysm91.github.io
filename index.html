<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏàòÏñ¥ ÌïôÏäµ Î∞è Ïù∏Ïãù ÏãúÏä§ÌÖú</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-storage-compat.js"></script>
    
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 20px);
        }

        .camera-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .data-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn.secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .recognition-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .current-sign {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .confidence {
            font-size: 16px;
            opacity: 0.8;
        }

        .training-section {
            background: rgba(255, 152, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }

        .training-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .word-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: white;
            font-size: 14px;
            flex: 1;
        }

        .word-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .recording-indicator {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .trained-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .trained-word-item {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid rgba(255, 152, 0, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cloud-indicator {
            background: rgba(255, 193, 7, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .recognized-words-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .recognized-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            min-height: 100px;
        }

        .word-item {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .word-text {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
        }

        .word-time {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .remove-btn {
            background: rgba(244, 67, 54, 0.6);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .remove-btn:hover {
            background: rgba(244, 67, 54, 0.8);
        }

        .empty-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            margin: 20px 0;
        }

        .text-output {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 40px 20px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Arial', sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: #00ff00;
            border: 2px solid rgba(0, 255, 0, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .status.ready {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .status.recording {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }

        .status.cloud {
            background: rgba(255, 193, 7, 0.2);
            color: #FFC107;
        }

        .recording-progress {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .recording-progress-bar {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        h3 {
            margin-bottom: 15px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="camera-section">
            <h2>üé• ÏàòÏñ¥ ÌïôÏäµ Î∞è Ïù∏Ïãù</h2>
            
            <div id="status" class="status">ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ï§ë...</div>
            
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="canvasOverlay" class="canvas-overlay"></canvas>
            </div>
            
            <div class="controls">
                <button id="startBtn" class="btn" onclick="startDetection()">Ïπ¥Î©îÎùº ÏãúÏûë</button>
                <button id="recognitionBtn" class="btn secondary" onclick="toggleRecognition()" disabled>Ïù∏Ïãù Î™®Îìú</button>
            </div>
            
            <div class="recognition-display">
                <div class="current-sign" id="currentSign">ÎåÄÍ∏∞ Ï§ë...</div>
                <div class="confidence" id="confidence">Ïã†Î¢∞ÎèÑ: 0%</div>
            </div>
        </div>

        <div class="data-section">
            <div class="training-section">
                <h3>üìö ÏàòÏñ¥ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÌïôÏäµ)</h3>
                
                <div class="training-controls">
                    <input type="text" id="wordInput" class="word-input" placeholder="ÌïôÏäµÌï† ÏàòÏñ¥ Îã®Ïñ¥ ÏûÖÎ†• (Ïòà: ÏïàÎÖïÌïòÏÑ∏Ïöî)">
                    <button id="recordBtn" class="btn danger" onclick="toggleRecording()" disabled>ÎÖπÌôî ÏãúÏûë</button>
                </div>
                
                <div class="recording-progress">
                    <div class="recording-progress-bar" id="progressBar"></div>
                </div>
                
                <div id="trainedWordsList" class="trained-words-list">
                    <div class="empty-message">FirebaseÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
                </div>
            </div>
            
            <div class="recognized-words-section">
                <h3>üí¨ Ïù∏ÏãùÎêú Îã®Ïñ¥</h3>
                <button class="btn danger" onclick="clearRecognizedWords()" style="margin-bottom: 10px;">Ïù∏Ïãù Í∏∞Î°ù ÏßÄÏö∞Í∏∞</button>
                <div class="recognized-words-list" id="recognizedWordsList">
                    <div class="empty-message">Ïù∏ÏãùÎêú Îã®Ïñ¥Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§</div>
                </div>
            </div>
            
            <div class="text-output" id="textOutput">
                <div id="currentText" style="color: #888;">
                    ÏàòÏñ¥Î•º ÌïôÏäµÏãúÌÇ® ÌõÑ Ïù∏Ïãù Î™®ÎìúÏóêÏÑú<br>
                    Ïã§ÏãúÍ∞Ñ Ïù∏Ïãù Í≤∞Í≥ºÍ∞Ä ÌëúÏãúÎê©ÎãàÎã§
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase ÏÑ§Ï†ï - Ïó¨Í∏∞Ïóê Î≥∏Ïù∏Ïùò Firebase ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî
        const firebaseConfig = {
            apiKey: "AIzaSyBAupMPBlNPPKPJM4Z4Jt-WAbPjSLwl2tY",
            authDomain: "korea-sign-language.firebaseapp.com",
            projectId: "korea-sign-language",
            storageBucket: "korea-sign-language.firebasestorage.app",
            messagingSenderId: "510105278291",
            appId: "1:510105278291:web:d6e8c23aa8fa9b19d133a6"
        };
        
        let db;
        let storage;
        let isFirebaseEnabled = false;

        function initializeFirebase() {
            try {
                if (firebaseConfig.apiKey === 'YOUR_API_KEY') {
                    console.warn('Firebase ÏÑ§Ï†ïÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î°úÏª¨ Ï†ÄÏû•ÏÜåÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.');
                    isFirebaseEnabled = false;
                    return false;
                }
                
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                storage = firebase.storage();
                isFirebaseEnabled = true;
                console.log('Firebase Ïó∞Í≤∞ ÏÑ±Í≥µ');
                return true;
            } catch (error) {
                console.error('Firebase Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                isFirebaseEnabled = false;
                return false;
            }
        }

        async function saveToFirebase(word, signData, videoBlob = null) {
            if (!isFirebaseEnabled) return false;

            try {
                let videoUrl = null;
                
                if (videoBlob) {
                    const fileName = `videos/${Date.now()}_${word}.webm`;
                    const storageRef = storage.ref(fileName);
                    
                    const uploadTask = await storageRef.put(videoBlob);
                    videoUrl = await uploadTask.ref.getDownloadURL();
                    console.log('ÎπÑÎîîÏò§ ÏóÖÎ°úÎìú ÏôÑÎ£å:', videoUrl);
                }

                const dataToSave = {
                    word: word,
                    features: signData.features,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    videoUrl: videoUrl,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                await db.collection('signLanguageData').doc(word).set(dataToSave, { merge: true });
                
                console.log(`"${word}" Firebase Ï†ÄÏû• ÏôÑÎ£å${videoUrl ? ' (ÎπÑÎîîÏò§ Ìè¨Ìï®)' : ''}`);
                return true;

            } catch (error) {
                console.error('Firebase Ï†ÄÏû• Ïã§Ìå®:', error);
                return false;
            }
        }

        async function loadFromFirebase() {
            if (!isFirebaseEnabled) {
                loadFromLocalStorage();
                return;
            }

            try {
                const snapshot = await db.collection('signLanguageData')
                    .orderBy('updatedAt', 'desc')
                    .get();

                if (snapshot.empty) {
                    console.log('FirebaseÏóê Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå');
                    loadFromLocalStorage();
                    return;
                }

                trainedSigns = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    trainedSigns[data.word] = {
                        features: data.features,
                        timestamp: data.timestamp?.toMillis() || Date.now(),
                        fromCloud: true,
                        videoUrl: data.videoUrl
                    };
                });

                updateTrainedWordsList();
                console.log(`${snapshot.size}Í∞ú ÏàòÏñ¥ FirebaseÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞ ÏôÑÎ£å`);
                
                saveToLocalStorage();

            } catch (error) {
                console.error('Firebase Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:', error);
                loadFromLocalStorage();
            }
        }

        async function removeFromFirebase(word) {
            if (!isFirebaseEnabled) return;

            try {
                await db.collection('signLanguageData').doc(word).delete();
                console.log(`"${word}" FirebaseÏóêÏÑú ÏÇ≠Ï†ú ÏôÑÎ£å`);
            } catch (error) {
                console.error('Firebase ÏÇ≠Ï†ú Ïã§Ìå®:', error);
            }
        }

        let hands;
        let isDetecting = false;
        let isRecording = false;
        let isRecognizing = false;
        let trainedSigns = {};
        let recognizedWords = [];
        let currentRecording = null;
        let recordingInterval = null;
        let mediaRecorder = null;
        let recordedChunks = [];

        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 0,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);
        }

        function extractFeatures(landmarks) {
            if (!landmarks || landmarks.length === 0) return null;
            
            const features = [];
            let firstWrist = null;
            
            landmarks.forEach((hand, handIndex) => {
                const wrist = hand[0];
                if (handIndex === 0) firstWrist = wrist;
                
                const normalizedHand = hand.map(point => ({
                    x: point.x - wrist.x,
                    y: point.y - wrist.y,
                    z: point.z - wrist.z
                }));
                
                for (let i = 0; i < normalizedHand.length; i++) {
                    features.push(normalizedHand[i].x, normalizedHand[i].y, normalizedHand[i].z);
                }
                
                const fingerTips = [4, 8, 12, 16, 20];
                for (let i = 0; i < fingerTips.length; i++) {
                    for (let j = i + 1; j < fingerTips.length; j++) {
                        const p1 = normalizedHand[fingerTips[i]];
                        const p2 = normalizedHand[fingerTips[j]];
                        const distance = Math.sqrt(
                            Math.pow(p1.x - p2.x, 2) + 
                            Math.pow(p1.y - p2.y, 2) + 
                            Math.pow(p1.z - p2.z, 2)
                        );
                        features.push(distance);
                    }
                }
                
                const fingerJoints = [
                    [0, 1, 2, 3, 4],
                    [0, 5, 6, 7, 8],
                    [0, 9, 10, 11, 12],
                    [0, 13, 14, 15, 16],
                    [0, 17, 18, 19, 20]
                ];
                
                fingerJoints.forEach(joints => {
                    for (let i = 0; i < joints.length - 2; i++) {
                        const p1 = normalizedHand[joints[i]];
                        const p2 = normalizedHand[joints[i + 1]];
                        const p3 = normalizedHand[joints[i + 2]];
                        
                        const v1 = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z };
                        const v2 = { x: p3.x - p2.x, y: p3.y - p2.y, z: p3.z - p2.z };
                        
                        const dot = v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
                        const len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z);
                        const len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y + v2.z * v2.z);
                        
                        const angle = len1 > 0 && len2 > 0 ? dot / (len1 * len2) : 0;
                        features.push(angle);
                    }
                });

                const palmSize = Math.sqrt(
                    Math.pow(normalizedHand[5].x - normalizedHand[17].x, 2) +
                    Math.pow(normalizedHand[5].y - normalizedHand[17].y, 2)
                );
                features.push(palmSize);
                
                fingerTips.forEach(tip => {
                    const distance = Math.sqrt(
                        Math.pow(normalizedHand[tip].x, 2) +
                        Math.pow(normalizedHand[tip].y, 2) +
                        Math.pow(normalizedHand[tip].z, 2)
                    );
                    features.push(distance);
                });
            });

            if (firstWrist) {
                features.push(firstWrist.x, firstWrist.y, firstWrist.z);
            }
            
            return features;
        }

        function calculateSimilarity(features1, features2) {
            if (!features1 || !features2) return 0;
            if (features1.length !== features2.length) return 0;
            
            let dotProduct = 0;
            let norm1 = 0;
            let norm2 = 0;
            
            for (let i = 0; i < features1.length; i++) {
                dotProduct += features1[i] * features2[i];
                norm1 += features1[i] * features1[i];
                norm2 += features2[i] * features2[i];
            }
            
            norm1 = Math.sqrt(norm1);
            norm2 = Math.sqrt(norm2);
            
            if (norm1 === 0 || norm2 === 0) return 0;
            
            return dotProduct / (norm1 * norm2);
        }

        function dtw(seq1, seq2) {
            const n = seq1.length;
            const m = seq2.length;
            const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
            
            dtw[0][0] = 0;
            
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    const cost = 1 - calculateSimilarity(seq1[i - 1], seq2[j - 1]);
                    dtw[i][j] = cost + Math.min(
                        dtw[i - 1][j],
                        dtw[i][j - 1],
                        dtw[i - 1][j - 1]
                    );
                }
            }
            
            return dtw[n][m] / Math.max(n, m);
        }

        function recognizeSign(currentFeatures) {
            let bestMatch = null;
            let bestSimilarity = 0;
            const threshold = 0.65;
            const minFrames = 15;
            
            if (recentFrames.length < minFrames) {
                return null;
            }
            
            for (const [word, signData] of Object.entries(trainedSigns)) {
                if (!signData.features || signData.features.length < minFrames) {
                    continue;
                }
                
                const dtwDistance = dtw(
                    recentFrames.slice(-25),
                    signData.features
                );
                
                const similarity = Math.max(0, 1 - dtwDistance);
                
                if (similarity > bestSimilarity) {
                    bestSimilarity = similarity;
                    bestMatch = word;
                }
            }
            
            if (bestSimilarity > threshold) {
                let secondBestSimilarity = 0;
                for (const [word, signData] of Object.entries(trainedSigns)) {
                    if (word === bestMatch) continue;
                    if (!signData.features || signData.features.length < minFrames) {
                        continue;
                    }
                    
                    const dtwDistance = dtw(
                        recentFrames.slice(-25),
                        signData.features
                    );
                    const similarity = Math.max(0, 1 - dtwDistance);
                    
                    if (similarity > secondBestSimilarity) {
                        secondBestSimilarity = similarity;
                    }
                }
                
                const confidenceGap = bestSimilarity - secondBestSimilarity;
                if (confidenceGap < 0.05) {
                    console.log(`Î∂àÌôïÏã§Ìïú Ïù∏Ïãù: ${bestMatch} (Ï∞®Ïù¥: ${(confidenceGap * 100).toFixed(1)}%)`);
                    return { word: bestMatch, confidence: bestSimilarity };
                }
                
                return { word: bestMatch, confidence: bestSimilarity };
            }
            
            return null;
        }

        let recentFrames = [];
        const MAX_FRAMES = 40;
        let lastProcessTime = 0;
        const PROCESS_INTERVAL = 300;
        const MIN_CONFIDENCE_THRESHOLD = 0.65;
        const MIN_RECOGNITION_FRAMES = 15;

        function onHandsResults(results) {
            drawHandLandmarks(results);
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if (!isRecording) {
                    document.getElementById('currentSign').textContent = 'ÏÜêÏù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏùå';
                    document.getElementById('confidence').textContent = 'Ïã†Î¢∞ÎèÑ: 0%';
                }
                if (isRecognizing && recentFrames.length > 0) {
                    recentFrames = [];
                }
                return;
            }
            
            const features = extractFeatures(results.multiHandLandmarks);
            
            if (!features) {
                return;
            }
            
            if (isRecording && currentRecording) {
                currentRecording.features.push(features);
                currentRecording.landmarks.push(results.multiHandLandmarks);
            }
            
            if (isRecognizing && !isRecording) {
                const now = Date.now();
                if (now - lastProcessTime < PROCESS_INTERVAL) {
                    return;
                }
                lastProcessTime = now;

                recentFrames.push(features);
                if (recentFrames.length > MAX_FRAMES) {
                    recentFrames.shift();
                }
                
                if (recentFrames.length >= MIN_RECOGNITION_FRAMES) {
                    const recognition = recognizeSign(features);
                    
                    if (recognition && recognition.confidence >= MIN_CONFIDENCE_THRESHOLD) {
                        document.getElementById('currentSign').textContent = recognition.word;
                        document.getElementById('confidence').textContent = 
                            `Ïã†Î¢∞ÎèÑ: ${Math.round(recognition.confidence * 100)}%`;
                        
                        addRecognizedWord(recognition.word);
                        
                        document.getElementById('currentText').textContent = recognition.word;
                        document.getElementById('currentText').style.color = '#00ff00';
                    } else {
                        document.getElementById('currentSign').textContent = 'Ïù∏Ïãù Ï§ë...';
                        document.getElementById('confidence').textContent = 
                            recognition ? `Ïã†Î¢∞ÎèÑ: ${Math.round(recognition.confidence * 100)}% (ÎÇÆÏùå)` : 'Ïã†Î¢∞ÎèÑ: ÎÇÆÏùå';
                    }
                } else {
                    document.getElementById('currentSign').textContent = 'ÏÜêÎèôÏûë ÏàòÏßë Ï§ë...';
                    document.getElementById('confidence').textContent = `ÌîÑÎ†àÏûÑ: ${recentFrames.length}/${MIN_RECOGNITION_FRAMES}`;
                }
            }
        }

        function drawHandLandmarks(results) {
            const canvas = document.getElementById('canvasOverlay');
            const video = document.getElementById('videoElement');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth || video.offsetWidth;
            canvas.height = video.videoHeight || video.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handColor = index === 0 ? '#00ff00' : '#ff6600';
                    
                    ctx.strokeStyle = handColor;
                    ctx.lineWidth = 2;
                    
                    const connections = [
                        [0,1],[1,2],[2,3],[3,4],
                        [0,5],[5,6],[6,7],[7,8],
                        [0,9],[9,10],[10,11],[11,12],
                        [0,13],[13,14],[14,15],[15,16],
                        [0,17],[17,18],[18,19],[19,20],
                        [5,9],[9,13],[13,17]
                    ];
                    
                    connections.forEach(([start, end]) => {
                        const startPoint = landmarks[start];
                        const endPoint = landmarks[end];
                        
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
                        ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
                        ctx.stroke();
                    });
                    
                    landmarks.forEach(point => {
                        const x = point.x * canvas.width;
                        const y = point.y * canvas.height;
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = handColor;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }
        }

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const video = document.getElementById('videoElement');
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve);
                    };
                });
                
                return true;
            } catch (error) {
                console.error('Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïò§Î•ò:', error);
                document.getElementById('status').textContent = 'Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®';
                document.getElementById('status').className = 'status error';
                return false;
            }
        }

        async function startDetection() {
            const startBtn = document.getElementById('startBtn');
            const recordBtn = document.getElementById('recordBtn');
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (!isDetecting) {
                const cameraReady = await startCamera();
                if (cameraReady) {
                    const video = document.getElementById('videoElement');
                    
                    const processFrame = async () => {
                        if (isDetecting && video.readyState >= 2) {
                            await hands.send({ image: video });
                        }
                        if (isDetecting) {
                            requestAnimationFrame(processFrame);
                        }
                    };
                    
                    isDetecting = true;
                    startBtn.textContent = 'Ïπ¥Î©îÎùº Ï§ëÏßÄ';
                    startBtn.classList.add('danger');
                    recordBtn.disabled = false;
                    recognitionBtn.disabled = false;
                    status.textContent = 'Ï§ÄÎπÑ ÏôÑÎ£å';
                    status.className = 'status ready';
                    
                    processFrame();
                }
            } else {
                isDetecting = false;
                isRecognizing = false;
                startBtn.textContent = 'Ïπ¥Î©îÎùº ÏãúÏûë';
                startBtn.classList.remove('danger');
                recordBtn.disabled = true;
                recognitionBtn.disabled = true;
                recognitionBtn.textContent = 'Ïù∏Ïãù Î™®Îìú';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'Ïπ¥Î©îÎùº Ï§ëÏßÄÎê®';
                status.className = 'status';
                
                const video = document.getElementById('videoElement');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
            }
        }

        function toggleRecording() {
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            if (!isRecording) {
                const word = wordInput.value.trim();
                if (!word) {
                    alert('ÌïôÏäµÌï† ÏàòÏñ¥ Îã®Ïñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî');
                    return;
                }
                
                isRecording = true;
                recordedChunks = [];
                
                const video = document.getElementById('videoElement');
                const stream = video.srcObject;
                
                try {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'video/webm;codecs=vp8,opus'
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };
                    
                    mediaRecorder.start();
                } catch (error) {
                    console.error('MediaRecorder ÏãúÏûë Ïã§Ìå®:', error);
                }
                
                currentRecording = {
                    word: word,
                    features: [],
                    landmarks: [],
                    startTime: Date.now()
                };
                
                recordBtn.textContent = 'ÎÖπÌôî Ï§ëÏßÄ (5Ï¥à)';
                recordBtn.classList.add('recording-indicator');
                status.textContent = `"${word}" ÎÖπÌôî Ï§ë...`;
                status.className = 'status recording';
                wordInput.disabled = true;
                
                let progress = 0;
                recordingInterval = setInterval(() => {
                    progress += 10;
                    progressBar.style.width = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(recordingInterval);
                        stopRecording();
                    }
                }, 250);
                
            } else {
                stopRecording();
            }
        }

        async function stopRecording() {
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            isRecording = false;
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            recordBtn.textContent = 'ÎÖπÌôî ÏãúÏûë';
            recordBtn.classList.remove('recording-indicator');
            wordInput.disabled = false;
            progressBar.style.width = '0%';
            
            if (currentRecording && currentRecording.features.length > 0) {
                status.textContent = 'ÎπÑÎîîÏò§ Ï≤òÎ¶¨ Ï§ë...';
                status.className = 'status cloud';
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                let videoBlob = null;
                if (recordedChunks.length > 0) {
                    videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    console.log(`ÎπÑÎîîÏò§ ÌÅ¨Í∏∞: ${(videoBlob.size / 1024 / 1024).toFixed(2)} MB`);
                }
                
                const signData = {
                    features: currentRecording.features,
                    landmarks: currentRecording.landmarks,
                    timestamp: Date.now(),
                    fromCloud: false
                };
                
                trainedSigns[currentRecording.word] = signData;
                
                saveToLocalStorage();
                
                const cloudSaved = await saveToFirebase(currentRecording.word, signData, videoBlob);
                
                if (cloudSaved) {
                    trainedSigns[currentRecording.word].fromCloud = true;
                    status.textContent = `"${currentRecording.word}" ÌïôÏäµ ÏôÑÎ£å! (Firebase Ï†ÄÏû•Îê®${videoBlob ? ' + ÎπÑÎîîÏò§' : ''})`;
                    status.className = 'status cloud';
                } else {
                    status.textContent = `"${currentRecording.word}" ÌïôÏäµ ÏôÑÎ£å! (Î°úÏª¨ Ï†ÄÏû•Îê®)`;
                    status.className = 'status ready';
                }
                
                updateTrainedWordsList();
                
                wordInput.value = '';
            } else {
                status.textContent = 'ÎÖπÌôî Ïã§Ìå® - ÏÜêÏù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏùå';
                status.className = 'status error';
            }
            
            currentRecording = null;
            recordedChunks = [];
        }

        function toggleRecognition() {
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (Object.keys(trainedSigns).length === 0) {
                alert('Î®ºÏ†Ä ÏàòÏñ¥Î•º ÌïôÏäµÏãúÏºúÏ£ºÏÑ∏Ïöî!');
                return;
            }
            
            isRecognizing = !isRecognizing;
            
            if (isRecognizing) {
                recognitionBtn.textContent = 'Ïù∏Ïãù Ï§ëÏßÄ';
                recognitionBtn.classList.add('danger');
                status.textContent = 'Ïù∏Ïãù Î™®Îìú ÌôúÏÑ±Ìôî';
                status.className = 'status ready';
                recentFrames = [];
            } else {
                recognitionBtn.textContent = 'Ïù∏Ïãù Î™®Îìú';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'Ïù∏Ïãù Î™®Îìú ÎπÑÌôúÏÑ±Ìôî';
                status.className = 'status';
                document.getElementById('currentSign').textContent = 'ÎåÄÍ∏∞ Ï§ë...';
                document.getElementById('confidence').textContent = 'Ïã†Î¢∞ÎèÑ: 0%';
            }
        }

        function updateTrainedWordsList() {
            const listElement = document.getElementById('trainedWordsList');
            const words = Object.keys(trainedSigns);
            
            if (words.length === 0) {
                listElement.innerHTML = '<div class="empty-message">ÌïôÏäµÎêú ÏàòÏñ¥Í∞Ä ÏóÜÏäµÎãàÎã§</div>';
                return;
            }
            
            listElement.innerHTML = '';
            words.forEach(word => {
                const item = document.createElement('div');
                item.className = 'trained-word-item';
                const isFromCloud = trainedSigns[word].fromCloud;
                item.innerHTML = `
                    <span>${word}${isFromCloud ? '<span class="cloud-indicator">üî• Firebase</span>' : ''}</span>
                    <button class="remove-btn" onclick="removeTrainedWord('${word}')">ÏÇ≠Ï†ú</button>
                `;
                listElement.appendChild(item);
            });
        }

        async function removeTrainedWord(word) {
            if (confirm(`"${word}" ÏàòÏñ¥Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                const wasFromCloud = trainedSigns[word].fromCloud;
                
                delete trainedSigns[word];
                updateTrainedWordsList();
                saveToLocalStorage();
                
                if (wasFromCloud) {
                    await removeFromFirebase(word);
                }
            }
        }

        let lastRecognizedWord = '';
        let lastRecognizedTime = 0;
        const RECOGNITION_COOLDOWN = 2000;
        
        function addRecognizedWord(word) {
            const now = Date.now();
            
            if (word === lastRecognizedWord && (now - lastRecognizedTime) < RECOGNITION_COOLDOWN) {
                return;
            }
            
            lastRecognizedWord = word;
            lastRecognizedTime = now;
            
            const wordData = {
                text: word,
                timestamp: new Date(),
                id: Date.now()
            };
            
            recognizedWords.push(wordData);
            updateRecognizedWordsList();
        }

        function updateRecognizedWordsList() {
            const listElement = document.getElementById('recognizedWordsList');
            
            if (recognizedWords.length === 0) {
                listElement.innerHTML = '<div class="empty-message">Ïù∏ÏãùÎêú Îã®Ïñ¥Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§</div>';
                return;
            }
            
            listElement.innerHTML = '';
            
            recognizedWords.slice().reverse().forEach(wordData => {
                const item = document.createElement('div');
                item.className = 'word-item';
                item.innerHTML = `
                    <div>
                        <div class="word-text">${wordData.text}</div>
                        <div class="word-time">${formatTime(wordData.timestamp)}</div>
                    </div>
                    <button class="remove-btn" onclick="removeRecognizedWord(${wordData.id})">ÏÇ≠Ï†ú</button>
                `;
                listElement.appendChild(item);
            });
        }

        function removeRecognizedWord(id) {
            recognizedWords = recognizedWords.filter(word => word.id !== id);
            updateRecognizedWordsList();
        }

        function clearRecognizedWords() {
            if (recognizedWords.length === 0) return;
            
            if (confirm('Î™®Îì† Ïù∏Ïãù Í∏∞Î°ùÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                recognizedWords = [];
                updateRecognizedWordsList();
                document.getElementById('currentText').textContent = 'ÏàòÏñ¥Î•º ÌïôÏäµÏãúÌÇ® ÌõÑ Ïù∏Ïãù Î™®ÎìúÏóêÏÑú\nÏã§ÏãúÍ∞Ñ Ïù∏Ïãù Í≤∞Í≥ºÍ∞Ä ÌëúÏãúÎê©ÎãàÎã§';
                document.getElementById('currentText').style.color = '#888';
            }
        }

        function formatTime(timestamp) {
            const now = new Date();
            const time = new Date(timestamp);
            const diff = now - time;
            
            if (diff < 60000) {
                return 'Î∞©Í∏à Ï†Ñ';
            } else if (diff < 3600000) {
                return `${Math.floor(diff / 60000)}Î∂Ñ Ï†Ñ`;
            } else {
                return time.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
            }
        }

        function saveToLocalStorage() {
            try {
                const data = {
                    trainedSigns: {},
                    savedAt: Date.now()
                };
                
                for (const [word, signData] of Object.entries(trainedSigns)) {
                    data.trainedSigns[word] = {
                        features: signData.features,
                        timestamp: signData.timestamp,
                        fromCloud: signData.fromCloud || false
                    };
                }
                
                localStorage.setItem('signLanguageData', JSON.stringify(data));
                console.log('Î°úÏª¨ Ï†ÄÏû• ÏôÑÎ£å');
            } catch (error) {
                console.error('Î°úÏª¨ Ï†ÄÏû• Ïò§Î•ò:', error);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('signLanguageData');
                if (saved) {
                    const data = JSON.parse(saved);
                    trainedSigns = data.trainedSigns || {};
                    updateTrainedWordsList();
                    console.log(`${Object.keys(trainedSigns).length}Í∞úÏùò ÏàòÏñ¥Î•º Î°úÏª¨ÏóêÏÑú Î∂àÎü¨ÏôîÏäµÎãàÎã§`);
                }
            } catch (error) {
                console.error('Î°úÏª¨ Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò:', error);
            }
        }

        window.addEventListener('load', async () => {
            console.log('ÏàòÏñ¥ ÌïôÏäµ Î∞è Ïù∏Ïãù ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî');
            
            const status = document.getElementById('status');
            status.textContent = 'Firebase Ïó∞Í≤∞ Ï§ë...';
            status.className = 'status cloud';
            
            initializeFirebase();
            
            setTimeout(async () => {
                if (typeof Hands !== 'undefined') {
                    initializeHands();
                    
                    await loadFromFirebase();
                    
                    status.textContent = isFirebaseEnabled ? 
                        'ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å (Firebase Ïó∞Í≤∞Îê®)' : 
                        'ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å (Î°úÏª¨ Î™®Îìú)';
                    status.className = 'status ready';
                } else {
                    status.textContent = 'MediaPipe Î°úÎî© Ïã§Ìå®';
                    status.className = 'status error';
                }
            }, 2000);
        });

        window.addEventListener('beforeunload', () => {
            if (Object.keys(trainedSigns).length > 0) {
                saveToLocalStorage();
            }
        });
    </script>
</body>
</html>
