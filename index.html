<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìˆ˜ì–´ í•™ìŠµ ë° ì¸ì‹ ì‹œìŠ¤í…œ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 20px);
        }

        .camera-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .data-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn.secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .recognition-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .current-sign {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .confidence {
            font-size: 16px;
            opacity: 0.8;
        }

        .training-section {
            background: rgba(255, 152, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }

        .training-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .word-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: white;
            font-size: 14px;
            flex: 1;
        }

        .word-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .recording-indicator {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .trained-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .trained-word-item {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid rgba(255, 152, 0, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cloud-indicator {
            background: rgba(76, 175, 80, 0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .recognized-words-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .recognized-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            min-height: 100px;
        }

        .word-item {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .word-text {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
        }

        .word-time {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .remove-btn {
            background: rgba(244, 67, 54, 0.6);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .remove-btn:hover {
            background: rgba(244, 67, 54, 0.8);
        }

        .empty-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            margin: 20px 0;
        }

        .text-output {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 40px 20px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Arial', sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: #00ff00;
            border: 2px solid rgba(0, 255, 0, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .status.ready {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .status.recording {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }

        .status.cloud {
            background: rgba(156, 39, 176, 0.2);
            color: #9C27B0;
        }

        .recording-progress {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .recording-progress-bar {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        h3 {
            margin-bottom: 15px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="camera-section">
            <h2>ğŸ¥ ìˆ˜ì–´ í•™ìŠµ ë° ì¸ì‹</h2>
            
            <div id="status" class="status">ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>
            
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="canvasOverlay" class="canvas-overlay"></canvas>
            </div>
            
            <div class="controls">
                <button id="startBtn" class="btn" onclick="startDetection()">ì¹´ë©”ë¼ ì‹œì‘</button>
                <button id="recognitionBtn" class="btn secondary" onclick="toggleRecognition()" disabled>ì¸ì‹ ëª¨ë“œ</button>
            </div>
            
            <div class="recognition-display">
                <div class="current-sign" id="currentSign">ëŒ€ê¸° ì¤‘...</div>
                <div class="confidence" id="confidence">ì‹ ë¢°ë„: 0%</div>
            </div>
        </div>

        <div class="data-section">
            <div class="training-section">
                <h3>ğŸ“š ìˆ˜ì–´ ë°ì´í„° ìˆ˜ì§‘ (í•™ìŠµ)</h3>
                
                <div class="training-controls">
                    <input type="text" id="wordInput" class="word-input" placeholder="í•™ìŠµí•  ìˆ˜ì–´ ë‹¨ì–´ ì…ë ¥ (ì˜ˆ: ì•ˆë…•í•˜ì„¸ìš”)">
                    <button id="recordBtn" class="btn danger" onclick="toggleRecording()" disabled>ë…¹í™” ì‹œì‘</button>
                </div>
                
                <div class="recording-progress">
                    <div class="recording-progress-bar" id="progressBar"></div>
                </div>
                
                <div id="trainedWordsList" class="trained-words-list">
                    <div class="empty-message">í´ë¼ìš°ë“œì—ì„œ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
                </div>
            </div>
            
            <div class="recognized-words-section">
                <h3>ğŸ’¬ ì¸ì‹ëœ ë‹¨ì–´</h3>
                <button class="btn danger" onclick="clearRecognizedWords()" style="margin-bottom: 10px;">ì¸ì‹ ê¸°ë¡ ì§€ìš°ê¸°</button>
                <div class="recognized-words-list" id="recognizedWordsList">
                    <div class="empty-message">ì¸ì‹ëœ ë‹¨ì–´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
                </div>
            </div>
            
            <div class="text-output" id="textOutput">
                <div id="currentText" style="color: #888;">
                    ìˆ˜ì–´ë¥¼ í•™ìŠµì‹œí‚¨ í›„ ì¸ì‹ ëª¨ë“œì—ì„œ<br>
                    ì‹¤ì‹œê°„ ì¸ì‹ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤
                </div>
            </div>
        </div>
    </div>

    <script>
        // Supabase ì„¤ì • (ì‹¤ì œ ê°’ìœ¼ë¡œ ë³€ê²½í•˜ì„¸ìš”)
        const SUPABASE_URL = 'https://qmddevysfschoeairtjg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFtZGRldnlzZnNjaG9lYWlydGpnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg5OTM3NzAsImV4cCI6MjA3NDU2OTc3MH0.aGrQq1-VPSEv3yXUjpDlk_LkEarq3ZwCY86JKIhFW5s';
        
        let supabase;
        let isSupabaseEnabled = false;

        // Supabase ì´ˆê¸°í™”
        function initializeSupabase() {
            try {
                if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                    console.warn('Supabase ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¡œì»¬ ì €ì¥ì†Œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                    isSupabaseEnabled = false;
                    return false;
                }
                
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isSupabaseEnabled = true;
                console.log('Supabase ì—°ê²° ì„±ê³µ');
                return true;
            } catch (error) {
                console.error('Supabase ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                isSupabaseEnabled = false;
                return false;
            }
        }

        // í´ë¼ìš°ë“œì— ìë™ ì €ì¥
        async function saveToCloudAuto(word, signData) {
            if (!isSupabaseEnabled) return false;

            try {
                const dataToSave = {
                    word: word,
                    features: JSON.stringify(signData.features),
                    timestamp: new Date(signData.timestamp).toISOString()
                };

                // ê¸°ì¡´ ê°™ì€ ë‹¨ì–´ê°€ ìˆìœ¼ë©´ ì—…ë°ì´íŠ¸, ì—†ìœ¼ë©´ ì¶”ê°€
                const { data: existing } = await supabase
                    .from('sign_language_data')
                    .select('id')
                    .eq('word', word)
                    .single();

                let result;
                if (existing) {
                    result = await supabase
                        .from('sign_language_data')
                        .update(dataToSave)
                        .eq('word', word);
                } else {
                    result = await supabase
                        .from('sign_language_data')
                        .insert([dataToSave]);
                }

                if (result.error) {
                    throw result.error;
                }

                console.log(`"${word}" í´ë¼ìš°ë“œ ì €ì¥ ì™„ë£Œ`);
                return true;

            } catch (error) {
                console.error('í´ë¼ìš°ë“œ ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
                return false;
            }
        }

        // í´ë¼ìš°ë“œì—ì„œ ìë™ ë¶ˆëŸ¬ì˜¤ê¸°
        async function loadFromCloudAuto() {
            if (!isSupabaseEnabled) {
                loadFromLocalStorage();
                return;
            }

            try {
                const { data, error } = await supabase
                    .from('sign_language_data')
                    .select('*')
                    .order('created_at', { ascending: false });

                if (error) {
                    console.error('í´ë¼ìš°ë“œ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                    loadFromLocalStorage();
                    return;
                }

                if (!data || data.length === 0) {
                    console.log('í´ë¼ìš°ë“œì— ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŒ');
                    loadFromLocalStorage();
                    return;
                }

                // í´ë¼ìš°ë“œ ë°ì´í„°ë¥¼ trainedSignsì— ë¡œë“œ
                trainedSigns = {};
                data.forEach(item => {
                    trainedSigns[item.word] = {
                        features: JSON.parse(item.features),
                        timestamp: new Date(item.created_at).getTime(),
                        fromCloud: true // í´ë¼ìš°ë“œì—ì„œ ì˜¨ ë°ì´í„°ì„ì„ í‘œì‹œ
                    };
                });

                updateTrainedWordsList();
                console.log(`${data.length}ê°œ ìˆ˜ì–´ í´ë¼ìš°ë“œì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ`);

                // ë¡œì»¬ì—ë„ ë°±ì—… ì €ì¥
                saveToLocalStorage();

            } catch (error) {
                console.error('í´ë¼ìš°ë“œ ìë™ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
                loadFromLocalStorage();
            }
        }

        // í´ë¼ìš°ë“œì—ì„œ ì‚­ì œ
        async function removeFromCloud(word) {
            if (!isSupabaseEnabled) return;

            try {
                const { error } = await supabase
                    .from('sign_language_data')
                    .delete()
                    .eq('word', word);

                if (error) {
                    console.error('í´ë¼ìš°ë“œ ì‚­ì œ ì‹¤íŒ¨:', error);
                } else {
                    console.log(`"${word}" í´ë¼ìš°ë“œì—ì„œ ì‚­ì œ ì™„ë£Œ`);
                }
            } catch (error) {
                console.error('í´ë¼ìš°ë“œ ì‚­ì œ ì‹¤íŒ¨:', error);
            }
        }

        // ì „ì—­ ë³€ìˆ˜
        let hands;
        let isDetecting = false;
        let isRecording = false;
        let isRecognizing = false;
        let trainedSigns = {};
        let recognizedWords = [];
        let currentRecording = null;
        let recordingInterval = null;

        // MediaPipe Hands ì´ˆê¸°í™”
        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);
        }

        // ëœë“œë§ˆí¬ë¥¼ íŠ¹ì§• ë²¡í„°ë¡œ ë³€í™˜
        function extractFeatures(landmarks) {
            if (!landmarks || landmarks.length === 0) return null;
            
            const features = [];
            
            landmarks.forEach(hand => {
                const wrist = hand[0];
                const normalizedHand = hand.map(point => ({
                    x: point.x - wrist.x,
                    y: point.y - wrist.y,
                    z: point.z - wrist.z
                }));
                
                for (let i = 0; i < normalizedHand.length; i++) {
                    features.push(normalizedHand[i].x, normalizedHand[i].y, normalizedHand[i].z);
                }
            });
            
            return features;
        }

        // ë‘ íŠ¹ì§• ë²¡í„° ê°„ ìœ ì‚¬ë„ ê³„ì‚°
        function calculateSimilarity(features1, features2) {
            if (!features1 || !features2) return 0;
            if (features1.length !== features2.length) return 0;
            
            let dotProduct = 0;
            let norm1 = 0;
            let norm2 = 0;
            
            for (let i = 0; i < features1.length; i++) {
                dotProduct += features1[i] * features2[i];
                norm1 += features1[i] * features1[i];
                norm2 += features2[i] * features2[i];
            }
            
            norm1 = Math.sqrt(norm1);
            norm2 = Math.sqrt(norm2);
            
            if (norm1 === 0 || norm2 === 0) return 0;
            
            return dotProduct / (norm1 * norm2);
        }

        // DTW ì•Œê³ ë¦¬ì¦˜
        function dtw(seq1, seq2) {
            const n = seq1.length;
            const m = seq2.length;
            const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
            
            dtw[0][0] = 0;
            
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    const cost = 1 - calculateSimilarity(seq1[i - 1], seq2[j - 1]);
                    dtw[i][j] = cost + Math.min(
                        dtw[i - 1][j],
                        dtw[i][j - 1],
                        dtw[i - 1][j - 1]
                    );
                }
            }
            
            return dtw[n][m] / Math.max(n, m);
        }

        // ìˆ˜ì–´ ì¸ì‹
        function recognizeSign(currentFeatures) {
            let bestMatch = null;
            let bestSimilarity = 0;
            const threshold = 0.85;
            
            for (const [word, signData] of Object.entries(trainedSigns)) {
                if (!signData.features || signData.features.length === 0) continue;
                
                const similarity = calculateSimilarity(currentFeatures, signData.features[signData.features.length - 1]);
                
                if (similarity > bestSimilarity) {
                    bestSimilarity = similarity;
                    bestMatch = word;
                }
                
                if (signData.features.length > 5 && recentFrames.length > 5) {
                    const sequenceSimilarity = 1 - dtw(
                        recentFrames.slice(-Math.min(10, recentFrames.length)),
                        signData.features.slice(-Math.min(10, signData.features.length))
                    );
                    
                    if (sequenceSimilarity > bestSimilarity) {
                        bestSimilarity = sequenceSimilarity;
                        bestMatch = word;
                    }
                }
            }
            
            if (bestSimilarity > threshold) {
                return { word: bestMatch, confidence: bestSimilarity };
            }
            
            return null;
        }

        // ìµœê·¼ í”„ë ˆì„ ì €ì¥
        let recentFrames = [];
        const MAX_FRAMES = 30;

        // ì† ì¸ì‹ ê²°ê³¼ ì²˜ë¦¬
        function onHandsResults(results) {
            drawHandLandmarks(results);
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if (!isRecording) {
                    document.getElementById('currentSign').textContent = 'ì†ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ';
                    document.getElementById('confidence').textContent = 'ì‹ ë¢°ë„: 0%';
                }
                return;
            }
            
            const features = extractFeatures(results.multiHandLandmarks);
            
            if (isRecording && currentRecording) {
                currentRecording.features.push(features);
                currentRecording.landmarks.push(results.multiHandLandmarks);
            }
            
            if (isRecognizing && !isRecording) {
                recentFrames.push(features);
                if (recentFrames.length > MAX_FRAMES) {
                    recentFrames.shift();
                }
                
                const recognition = recognizeSign(features);
                
                if (recognition) {
                    document.getElementById('currentSign').textContent = recognition.word;
                    document.getElementById('confidence').textContent = 
                        `ì‹ ë¢°ë„: ${Math.round(recognition.confidence * 100)}%`;
                    
                    addRecognizedWord(recognition.word);
                    
                    document.getElementById('currentText').textContent = recognition.word;
                    document.getElementById('currentText').style.color = '#00ff00';
                } else {
                    document.getElementById('currentSign').textContent = 'ì¸ì‹ ì¤‘...';
                    document.getElementById('confidence').textContent = 'ì‹ ë¢°ë„: ë‚®ìŒ';
                }
            }
        }

        // ì† ëœë“œë§ˆí¬ ê·¸ë¦¬ê¸°
        function drawHandLandmarks(results) {
            const canvas = document.getElementById('canvasOverlay');
            const video = document.getElementById('videoElement');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth || video.offsetWidth;
            canvas.height = video.videoHeight || video.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handColor = index === 0 ? '#00ff00' : '#ff6600';
                    
                    ctx.strokeStyle = handColor;
                    ctx.lineWidth = 2;
                    
                    const connections = [
                        [0,1],[1,2],[2,3],[3,4],
                        [0,5],[5,6],[6,7],[7,8],
                        [0,9],[9,10],[10,11],[11,12],
                        [0,13],[13,14],[14,15],[15,16],
                        [0,17],[17,18],[18,19],[19,20],
                        [5,9],[9,13],[13,17]
                    ];
                    
                    connections.forEach(([start, end]) => {
                        const startPoint = landmarks[start];
                        const endPoint = landmarks[end];
                        
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
                        ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
                        ctx.stroke();
                    });
                    
                    landmarks.forEach(point => {
                        const x = point.x * canvas.width;
                        const y = point.y * canvas.height;
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = handColor;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }
        }

        // ì¹´ë©”ë¼ ì‹œì‘
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const video = document.getElementById('videoElement');
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve);
                    };
                });
                
                return true;
            } catch (error) {
                console.error('ì¹´ë©”ë¼ ì ‘ê·¼ ì˜¤ë¥˜:', error);
                document.getElementById('status').textContent = 'ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨';
                document.getElementById('status').className = 'status error';
                return false;
            }
        }

        // ì¹´ë©”ë¼ ì‹œì‘/ì¤‘ì§€
        async function startDetection() {
            const startBtn = document.getElementById('startBtn');
            const recordBtn = document.getElementById('recordBtn');
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (!isDetecting) {
                const cameraReady = await startCamera();
                if (cameraReady) {
                    const video = document.getElementById('videoElement');
                    
                    const processFrame = async () => {
                        if (isDetecting && video.readyState >= 2) {
                            await hands.send({ image: video });
                        }
                        if (isDetecting) {
                            requestAnimationFrame(processFrame);
                        }
                    };
                    
                    isDetecting = true;
                    startBtn.textContent = 'ì¹´ë©”ë¼ ì¤‘ì§€';
                    startBtn.classList.add('danger');
                    recordBtn.disabled = false;
                    recognitionBtn.disabled = false;
                    status.textContent = 'ì¤€ë¹„ ì™„ë£Œ';
                    status.className = 'status ready';
                    
                    processFrame();
                }
            } else {
                isDetecting = false;
                isRecognizing = false;
                startBtn.textContent = 'ì¹´ë©”ë¼ ì‹œì‘';
                startBtn.classList.remove('danger');
                recordBtn.disabled = true;
                recognitionBtn.disabled = true;
                recognitionBtn.textContent = 'ì¸ì‹ ëª¨ë“œ';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'ì¹´ë©”ë¼ ì¤‘ì§€ë¨';
                status.className = 'status';
                
                const video = document.getElementById('videoElement');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
            }
        }

        // ë…¹í™” ì‹œì‘/ì¤‘ì§€
        function toggleRecording() {
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            if (!isRecording) {
                const word = wordInput.value.trim();
                if (!word) {
                    alert('í•™ìŠµí•  ìˆ˜ì–´ ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
                    return;
                }
                
                // ë…¹í™” ì‹œì‘
                isRecording = true;
                currentRecording = {
                    word: word,
                    features: [],
                    landmarks: [],
                    startTime: Date.now()
                };
                
                recordBtn.textContent = 'ë…¹í™” ì¤‘ì§€ (3ì´ˆ)';
                recordBtn.classList.add('recording-indicator');
                status.textContent = `"${word}" ë…¹í™” ì¤‘...`;
                status.className = 'status recording';
                wordInput.disabled = true;
                
                // 3ì´ˆ ë…¹í™” ì§„í–‰ë¥  í‘œì‹œ
                let progress = 0;
                recordingInterval = setInterval(() => {
                    progress += 10;
                    progressBar.style.width = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(recordingInterval);
                        stopRecording();
                    }
                }, 300);
                
            } else {
                stopRecording();
            }
        }

        // ë…¹í™” ì¤‘ì§€ ë° í´ë¼ìš°ë“œ ì €ì¥
        async function stopRecording() {
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
            
            isRecording = false;
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            recordBtn.textContent = 'ë…¹í™” ì‹œì‘';
            recordBtn.classList.remove('recording-indicator');
            wordInput.disabled = false;
            progressBar.style.width = '0%';
            
            if (currentRecording && currentRecording.features.length > 0) {
                // í•™ìŠµ ë°ì´í„° ì €ì¥
                const signData = {
                    features: currentRecording.features,
                    landmarks: currentRecording.landmarks,
                    timestamp: Date.now(),
                    fromCloud: false
                };
                
                trainedSigns[currentRecording.word] = signData;
                
                // ë¡œì»¬ ì €ì¥
                saveToLocalStorage();
                
                // í´ë¼ìš°ë“œ ìë™ ì €ì¥
                const cloudSaved = await saveToCloudAuto(currentRecording.word, signData);
                
                if (cloudSaved) {
                    trainedSigns[currentRecording.word].fromCloud = true;
                    status.textContent = `"${currentRecording.word}" í•™ìŠµ ì™„ë£Œ! (í´ë¼ìš°ë“œ ì €ì¥ë¨)`;
                    status.className = 'status cloud';
                } else {
                    status.textContent = `"${currentRecording.word}" í•™ìŠµ ì™„ë£Œ! (ë¡œì»¬ ì €ì¥ë¨)`;
                    status.className = 'status ready';
                }
                
                updateTrainedWordsList();
                
                // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                wordInput.value = '';
            } else {
                status.textContent = 'ë…¹í™” ì‹¤íŒ¨ - ì†ì´ ê°ì§€ë˜ì§€ ì•ŠìŒ';
                status.className = 'status error';
            }
            
            currentRecording = null;
        }

        // ì¸ì‹ ëª¨ë“œ í† ê¸€
        function toggleRecognition() {
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (Object.keys(trainedSigns).length === 0) {
                alert('ë¨¼ì € ìˆ˜ì–´ë¥¼ í•™ìŠµì‹œì¼œì£¼ì„¸ìš”!');
                return;
            }
            
            isRecognizing = !isRecognizing;
            
            if (isRecognizing) {
                recognitionBtn.textContent = 'ì¸ì‹ ì¤‘ì§€';
                recognitionBtn.classList.add('danger');
                status.textContent = 'ì¸ì‹ ëª¨ë“œ í™œì„±í™”';
                status.className = 'status ready';
                recentFrames = [];
            } else {
                recognitionBtn.textContent = 'ì¸ì‹ ëª¨ë“œ';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'ì¸ì‹ ëª¨ë“œ ë¹„í™œì„±í™”';
                status.className = 'status';
                document.getElementById('currentSign').textContent = 'ëŒ€ê¸° ì¤‘...';
                document.getElementById('confidence').textContent = 'ì‹ ë¢°ë„: 0%';
            }
        }

        // í•™ìŠµëœ ë‹¨ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateTrainedWordsList() {
            const listElement = document.getElementById('trainedWordsList');
            const words = Object.keys(trainedSigns);
            
            if (words.length === 0) {
                listElement.innerHTML = '<div class="empty-message">í•™ìŠµëœ ìˆ˜ì–´ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }
            
            listElement.innerHTML = '';
            words.forEach(word => {
                const item = document.createElement('div');
                item.className = 'trained-word-item';
                const isFromCloud = trainedSigns[word].fromCloud;
                item.innerHTML = `
                    <span>${word}${isFromCloud ? '<span class="cloud-indicator">â˜ï¸</span>' : ''}</span>
                    <button class="remove-btn" onclick="removeTrainedWord('${word}')">ì‚­ì œ</button>
                `;
                listElement.appendChild(item);
            });
        }

        // í•™ìŠµëœ ë‹¨ì–´ ì‚­ì œ
        async function removeTrainedWord(word) {
            if (confirm(`"${word}" ìˆ˜ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                const wasFromCloud = trainedSigns[word].fromCloud;
                
                delete trainedSigns[word];
                updateTrainedWordsList();
                saveToLocalStorage();
                
                // í´ë¼ìš°ë“œì—ì„œë„ ì‚­ì œ
                if (wasFromCloud) {
                    await removeFromCloud(word);
                }
            }
        }

        // ì¸ì‹ëœ ë‹¨ì–´ ì¶”ê°€
        let lastRecognizedWord = '';
        let lastRecognizedTime = 0;
        
        function addRecognizedWord(word) {
            const now = Date.now();
            
            if (word === lastRecognizedWord && now - lastRecognizedTime < 2000) {
                return;
            }
            
            lastRecognizedWord = word;
            lastRecognizedTime = now;
            
            const wordData = {
                text: word,
                timestamp: new Date(),
                id: Date.now()
            };
            
            recognizedWords.push(wordData);
            updateRecognizedWordsList();
        }

        // ì¸ì‹ëœ ë‹¨ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
        function updateRecognizedWordsList() {
            const listElement = document.getElementById('recognizedWordsList');
            
            if (recognizedWords.length === 0) {
                listElement.innerHTML = '<div class="empty-message">ì¸ì‹ëœ ë‹¨ì–´ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>';
                return;
            }
            
            listElement.innerHTML = '';
            
            recognizedWords.slice().reverse().forEach(wordData => {
                const item = document.createElement('div');
                item.className = 'word-item';
                item.innerHTML = `
                    <div>
                        <div class="word-text">${wordData.text}</div>
                        <div class="word-time">${formatTime(wordData.timestamp)}</div>
                    </div>
                    <button class="remove-btn" onclick="removeRecognizedWord(${wordData.id})">ì‚­ì œ</button>
                `;
                listElement.appendChild(item);
            });
        }

        // ì¸ì‹ëœ ë‹¨ì–´ ì‚­ì œ
        function removeRecognizedWord(id) {
            recognizedWords = recognizedWords.filter(word => word.id !== id);
            updateRecognizedWordsList();
        }

        // ì¸ì‹ ê¸°ë¡ ì „ì²´ ì‚­ì œ
        function clearRecognizedWords() {
            if (recognizedWords.length === 0) return;
            
            if (confirm('ëª¨ë“  ì¸ì‹ ê¸°ë¡ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                recognizedWords = [];
                updateRecognizedWordsList();
                document.getElementById('currentText').textContent = 'ìˆ˜ì–´ë¥¼ í•™ìŠµì‹œí‚¨ í›„ ì¸ì‹ ëª¨ë“œì—ì„œ\nì‹¤ì‹œê°„ ì¸ì‹ ê²°ê³¼ê°€ í‘œì‹œë©ë‹ˆë‹¤';
                document.getElementById('currentText').style.color = '#888';
            }
        }

        // ì‹œê°„ í¬ë§·íŒ…
        function formatTime(timestamp) {
            const now = new Date();
            const time = new Date(timestamp);
            const diff = now - time;
            
            if (diff < 60000) {
                return 'ë°©ê¸ˆ ì „';
            } else if (diff < 3600000) {
                return `${Math.floor(diff / 60000)}ë¶„ ì „`;
            } else {
                return time.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
            }
        }

        // LocalStorageì— ì €ì¥
        function saveToLocalStorage() {
            try {
                const data = {
                    trainedSigns: {},
                    savedAt: Date.now()
                };
                
                for (const [word, signData] of Object.entries(trainedSigns)) {
                    data.trainedSigns[word] = {
                        features: signData.features,
                        timestamp: signData.timestamp,
                        fromCloud: signData.fromCloud || false
                    };
                }
                
                localStorage.setItem('signLanguageData', JSON.stringify(data));
                console.log('ë¡œì»¬ ì €ì¥ ì™„ë£Œ');
            } catch (error) {
                console.error('ë¡œì»¬ ì €ì¥ ì˜¤ë¥˜:', error);
            }
        }

        // LocalStorageì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('signLanguageData');
                if (saved) {
                    const data = JSON.parse(saved);
                    trainedSigns = data.trainedSigns || {};
                    updateTrainedWordsList();
                    console.log(`${Object.keys(trainedSigns).length}ê°œì˜ ìˆ˜ì–´ë¥¼ ë¡œì»¬ì—ì„œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤`);
                }
            } catch (error) {
                console.error('ë¡œì»¬ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
            }
        }

        // ì´ˆê¸°í™”
        window.addEventListener('load', async () => {
            console.log('ìˆ˜ì–´ í•™ìŠµ ë° ì¸ì‹ ì‹œìŠ¤í…œ ì´ˆê¸°í™”');
            
            const status = document.getElementById('status');
            status.textContent = 'Supabase ì—°ê²° ì¤‘...';
            status.className = 'status cloud';
            
            // Supabase ì´ˆê¸°í™”
            initializeSupabase();
            
            // MediaPipe ë¡œë”© ëŒ€ê¸°
            setTimeout(async () => {
                if (typeof Hands !== 'undefined') {
                    initializeHands();
                    
                    // í´ë¼ìš°ë“œ ë˜ëŠ” ë¡œì»¬ì—ì„œ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
                    await loadFromCloudAuto();
                    
                    status.textContent = isSupabaseEnabled ? 
                        'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ (í´ë¼ìš°ë“œ ì—°ê²°ë¨)' : 
                        'ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ (ë¡œì»¬ ëª¨ë“œ)';
                    status.className = 'status ready';
                } else {
                    status.textContent = 'MediaPipe ë¡œë”© ì‹¤íŒ¨';
                    status.className = 'status error';
                }
            }, 2000);
        });

        // í˜ì´ì§€ ë– ë‚  ë•Œ ìë™ ì €ì¥
        window.addEventListener('beforeunload', () => {
            if (Object.keys(trainedSigns).length > 0) {
                saveToLocalStorage();
            }
        });
    </script>
</body>
</html>
