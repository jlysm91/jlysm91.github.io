<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏàòÏñ¥ ÌïôÏäµ Î∞è Ïù∏Ïãù ÏãúÏä§ÌÖú</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1620248257/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 20px);
        }

        .camera-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .data-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .btn.secondary {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }

        .btn.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .recognition-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .current-sign {
            font-size: 28px;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .confidence {
            font-size: 16px;
            opacity: 0.8;
        }

        .training-section {
            background: rgba(255, 152, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 152, 0, 0.3);
        }

        .training-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }

        .word-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 10px;
            color: white;
            font-size: 14px;
            flex: 1;
        }

        .word-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .recording-indicator {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .trained-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .trained-word-item {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid rgba(255, 152, 0, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cloud-indicator {
            background: rgba(76, 175, 80, 0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
        }

        .recognized-words-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .recognized-words-list {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            min-height: 100px;
        }

        .word-item {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.4);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .word-text {
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
        }

        .word-time {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .remove-btn {
            background: rgba(244, 67, 54, 0.6);
            border: none;
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .remove-btn:hover {
            background: rgba(244, 67, 54, 0.8);
        }

        .empty-message {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            margin: 20px 0;
        }

        .text-output {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 40px 20px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Arial', sans-serif;
            font-size: 32px;
            font-weight: bold;
            color: #00ff00;
            border: 2px solid rgba(0, 255, 0, 0.3);
            text-align: center;
            transition: all 0.3s ease;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .status.ready {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }

        .status.recording {
            background: rgba(255, 152, 0, 0.2);
            color: #FF9800;
        }

        .status.cloud {
            background: rgba(156, 39, 176, 0.2);
            color: #9C27B0;
        }

        .recording-progress {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            height: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .recording-progress-bar {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 20px;
            text-align: center;
            font-size: 24px;
        }

        h3 {
            margin-bottom: 15px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="camera-section">
            <h2>üé• ÏàòÏñ¥ ÌïôÏäµ Î∞è Ïù∏Ïãù</h2>
            
            <div id="status" class="status">ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî Ï§ë...</div>
            
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="canvasOverlay" class="canvas-overlay"></canvas>
            </div>
            
            <div class="controls">
                <button id="startBtn" class="btn" onclick="startDetection()">Ïπ¥Î©îÎùº ÏãúÏûë</button>
                <button id="recognitionBtn" class="btn secondary" onclick="toggleRecognition()" disabled>Ïù∏Ïãù Î™®Îìú</button>
            </div>
            
            <div class="recognition-display">
                <div class="current-sign" id="currentSign">ÎåÄÍ∏∞ Ï§ë...</div>
                <div class="confidence" id="confidence">Ïã†Î¢∞ÎèÑ: 0%</div>
            </div>
        </div>

        <div class="data-section">
            <div class="training-section">
                <h3>üìö ÏàòÏñ¥ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÌïôÏäµ)</h3>
                
                <div class="training-controls">
                    <input type="text" id="wordInput" class="word-input" placeholder="ÌïôÏäµÌï† ÏàòÏñ¥ Îã®Ïñ¥ ÏûÖÎ†• (Ïòà: ÏïàÎÖïÌïòÏÑ∏Ïöî)">
                    <button id="recordBtn" class="btn danger" onclick="toggleRecording()" disabled>ÎÖπÌôî ÏãúÏûë</button>
                </div>
                
                <div class="recording-progress">
                    <div class="recording-progress-bar" id="progressBar"></div>
                </div>
                
                <div id="trainedWordsList" class="trained-words-list">
                    <div class="empty-message">ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
                </div>
            </div>
            
            <div class="recognized-words-section">
                <h3>üí¨ Ïù∏ÏãùÎêú Îã®Ïñ¥</h3>
                <button class="btn danger" onclick="clearRecognizedWords()" style="margin-bottom: 10px;">Ïù∏Ïãù Í∏∞Î°ù ÏßÄÏö∞Í∏∞</button>
                <div class="recognized-words-list" id="recognizedWordsList">
                    <div class="empty-message">Ïù∏ÏãùÎêú Îã®Ïñ¥Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§</div>
                </div>
            </div>
            
            <div class="text-output" id="textOutput">
                <div id="currentText" style="color: #888;">
                    ÏàòÏñ¥Î•º ÌïôÏäµÏãúÌÇ® ÌõÑ Ïù∏Ïãù Î™®ÎìúÏóêÏÑú<br>
                    Ïã§ÏãúÍ∞Ñ Ïù∏Ïãù Í≤∞Í≥ºÍ∞Ä ÌëúÏãúÎê©ÎãàÎã§
                </div>
            </div>
        </div>
    </div>

    <script>
        // Supabase ÏÑ§Ï†ï (Ïã§Ï†ú Í∞íÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî)
        const SUPABASE_URL = 'https://qmddevysfschoeairtjg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFtZGRldnlzZnNjaG9lYWlydGpnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg5OTM3NzAsImV4cCI6MjA3NDU2OTc3MH0.aGrQq1-VPSEv3yXUjpDlk_LkEarq3ZwCY86JKIhFW5s';
        
        let supabase;
        let isSupabaseEnabled = false;

        // Supabase Ï¥àÍ∏∞Ìôî
        function initializeSupabase() {
            try {
                if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                    console.warn('Supabase ÏÑ§Ï†ïÏù¥ ÌïÑÏöîÌï©ÎãàÎã§. Î°úÏª¨ Ï†ÄÏû•ÏÜåÎ•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.');
                    isSupabaseEnabled = false;
                    return false;
                }
                
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isSupabaseEnabled = true;
                console.log('Supabase Ïó∞Í≤∞ ÏÑ±Í≥µ');
                return true;
            } catch (error) {
                console.error('Supabase Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                isSupabaseEnabled = false;
                return false;
            }
        }

        // ÌÅ¥ÎùºÏö∞ÎìúÏóê ÏûêÎèô Ï†ÄÏû•
        async function saveToCloudAuto(word, signData) {
            if (!isSupabaseEnabled) return false;

            try {
                const dataToSave = {
                    word: word,
                    features: JSON.stringify(signData.features),
                    created_at: new Date(signData.timestamp).toISOString()
                };

                // Í∏∞Ï°¥ Í∞ôÏùÄ Îã®Ïñ¥Í∞Ä ÏûàÏúºÎ©¥ ÏóÖÎç∞Ïù¥Ìä∏, ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
                const { data: existing } = await supabase
                    .from('sign_language_data')
                    .select('id')
                    .eq('word', word)
                    .single();

                let result;
                if (existing) {
                    result = await supabase
                        .from('sign_language_data')
                        .update(dataToSave)
                        .eq('word', word);
                } else {
                    result = await supabase
                        .from('sign_language_data')
                        .insert([dataToSave]);
                }

                if (result.error) {
                    throw result.error;
                }

                console.log(`"${word}" ÌÅ¥ÎùºÏö∞Îìú Ï†ÄÏû• ÏôÑÎ£å`);
                return true;

            } catch (error) {
                console.error('ÌÅ¥ÎùºÏö∞Îìú ÏûêÎèô Ï†ÄÏû• Ïã§Ìå®:', error);
                return false;
            }
        }

        // ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú ÏûêÎèô Î∂àÎü¨Ïò§Í∏∞
        async function loadFromCloudAuto() {
            if (!isSupabaseEnabled) {
                loadFromLocalStorage();
                return;
            }

            try {
                const { data, error } = await supabase
                    .from('sign_language_data')
                    .select('*')
                    .order('timestamp', { ascending: false });

                if (error) {
                    console.error('ÌÅ¥ÎùºÏö∞Îìú Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:', error);
                    loadFromLocalStorage();
                    return;
                }

                if (!data || data.length === 0) {
                    console.log('ÌÅ¥ÎùºÏö∞ÎìúÏóê Ï†ÄÏû•Îêú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå');
                    loadFromLocalStorage();
                    return;
                }

                // ÌÅ¥ÎùºÏö∞Îìú Îç∞Ïù¥ÌÑ∞Î•º trainedSignsÏóê Î°úÎìú
                trainedSigns = {};
                data.forEach(item => {
                    trainedSigns[item.word] = {
                        features: JSON.parse(item.features),
                        timestamp: new Date(item.timestamp).getTime(),
                        fromCloud: true // ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú Ïò® Îç∞Ïù¥ÌÑ∞ÏûÑÏùÑ ÌëúÏãú
                    };
                });

                updateTrainedWordsList();
                console.log(`${data.length}Í∞ú ÏàòÏñ¥ ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞ ÏôÑÎ£å`);

                // Î°úÏª¨ÏóêÎèÑ Î∞±ÏóÖ Ï†ÄÏû•
                saveToLocalStorage();

            } catch (error) {
                console.error('ÌÅ¥ÎùºÏö∞Îìú ÏûêÎèô Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:', error);
                loadFromLocalStorage();
            }
        }

        // ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú ÏÇ≠Ï†ú
        async function removeFromCloud(word) {
            if (!isSupabaseEnabled) return;

            try {
                const { error } = await supabase
                    .from('sign_language_data')
                    .delete()
                    .eq('word', word);

                if (error) {
                    console.error('ÌÅ¥ÎùºÏö∞Îìú ÏÇ≠Ï†ú Ïã§Ìå®:', error);
                } else {
                    console.log(`"${word}" ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑú ÏÇ≠Ï†ú ÏôÑÎ£å`);
                }
            } catch (error) {
                console.error('ÌÅ¥ÎùºÏö∞Îìú ÏÇ≠Ï†ú Ïã§Ìå®:', error);
            }
        }

        // Ï†ÑÏó≠ Î≥ÄÏàò
        let hands;
        let isDetecting = false;
        let isRecording = false;
        let isRecognizing = false;
        let trainedSigns = {};
        let recognizedWords = [];
        let currentRecording = null;
        let recordingInterval = null;

        // MediaPipe Hands Ï¥àÍ∏∞Ìôî
        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);
        }

        // ÎûúÎìúÎßàÌÅ¨Î•º ÌäπÏßï Î≤°ÌÑ∞Î°ú Î≥ÄÌôò
        function extractFeatures(landmarks) {
            if (!landmarks || landmarks.length === 0) return null;
            
            const features = [];
            
            landmarks.forEach(hand => {
                const wrist = hand[0];
                const normalizedHand = hand.map(point => ({
                    x: point.x - wrist.x,
                    y: point.y - wrist.y,
                    z: point.z - wrist.z
                }));
                
                for (let i = 0; i < normalizedHand.length; i++) {
                    features.push(normalizedHand[i].x, normalizedHand[i].y, normalizedHand[i].z);
                }
            });
            
            return features;
        }

        // Îëê ÌäπÏßï Î≤°ÌÑ∞ Í∞Ñ Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
        function calculateSimilarity(features1, features2) {
            if (!features1 || !features2) return 0;
            if (features1.length !== features2.length) return 0;
            
            let dotProduct = 0;
            let norm1 = 0;
            let norm2 = 0;
            
            for (let i = 0; i < features1.length; i++) {
                dotProduct += features1[i] * features2[i];
                norm1 += features1[i] * features1[i];
                norm2 += features2[i] * features2[i];
            }
            
            norm1 = Math.sqrt(norm1);
            norm2 = Math.sqrt(norm2);
            
            if (norm1 === 0 || norm2 === 0) return 0;
            
            return dotProduct / (norm1 * norm2);
        }

        // DTW ÏïåÍ≥†Î¶¨Ï¶ò
        function dtw(seq1, seq2) {
            const n = seq1.length;
            const m = seq2.length;
            const dtw = Array(n + 1).fill(null).map(() => Array(m + 1).fill(Infinity));
            
            dtw[0][0] = 0;
            
            for (let i = 1; i <= n; i++) {
                for (let j = 1; j <= m; j++) {
                    const cost = 1 - calculateSimilarity(seq1[i - 1], seq2[j - 1]);
                    dtw[i][j] = cost + Math.min(
                        dtw[i - 1][j],
                        dtw[i][j - 1],
                        dtw[i - 1][j - 1]
                    );
                }
            }
            
            return dtw[n][m] / Math.max(n, m);
        }

        // ÏàòÏñ¥ Ïù∏Ïãù
        function recognizeSign(currentFeatures) {
            let bestMatch = null;
            let bestSimilarity = 0;
            const threshold = 0.85;
            
            for (const [word, signData] of Object.entries(trainedSigns)) {
                if (!signData.features || signData.features.length === 0) continue;
                
                const similarity = calculateSimilarity(currentFeatures, signData.features[signData.features.length - 1]);
                
                if (similarity > bestSimilarity) {
                    bestSimilarity = similarity;
                    bestMatch = word;
                }
                
                if (signData.features.length > 5 && recentFrames.length > 5) {
                    const sequenceSimilarity = 1 - dtw(
                        recentFrames.slice(-Math.min(10, recentFrames.length)),
                        signData.features.slice(-Math.min(10, signData.features.length))
                    );
                    
                    if (sequenceSimilarity > bestSimilarity) {
                        bestSimilarity = sequenceSimilarity;
                        bestMatch = word;
                    }
                }
            }
            
            if (bestSimilarity > threshold) {
                return { word: bestMatch, confidence: bestSimilarity };
            }
            
            return null;
        }

        // ÏµúÍ∑º ÌîÑÎ†àÏûÑ Ï†ÄÏû•
        let recentFrames = [];
        const MAX_FRAMES = 30;

        // ÏÜê Ïù∏Ïãù Í≤∞Í≥º Ï≤òÎ¶¨
        function onHandsResults(results) {
            drawHandLandmarks(results);
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                if (!isRecording) {
                    document.getElementById('currentSign').textContent = 'ÏÜêÏù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏùå';
                    document.getElementById('confidence').textContent = 'Ïã†Î¢∞ÎèÑ: 0%';
                }
                return;
            }
            
            const features = extractFeatures(results.multiHandLandmarks);
            
            if (isRecording && currentRecording) {
                currentRecording.features.push(features);
                currentRecording.landmarks.push(results.multiHandLandmarks);
            }
            
            if (isRecognizing && !isRecording) {
                recentFrames.push(features);
                if (recentFrames.length > MAX_FRAMES) {
                    recentFrames.shift();
                }
                
                const recognition = recognizeSign(features);
                
                if (recognition) {
                    document.getElementById('currentSign').textContent = recognition.word;
                    document.getElementById('confidence').textContent = 
                        `Ïã†Î¢∞ÎèÑ: ${Math.round(recognition.confidence * 100)}%`;
                    
                    addRecognizedWord(recognition.word);
                    
                    document.getElementById('currentText').textContent = recognition.word;
                    document.getElementById('currentText').style.color = '#00ff00';
                } else {
                    document.getElementById('currentSign').textContent = 'Ïù∏Ïãù Ï§ë...';
                    document.getElementById('confidence').textContent = 'Ïã†Î¢∞ÎèÑ: ÎÇÆÏùå';
                }
            }
        }

        // ÏÜê ÎûúÎìúÎßàÌÅ¨ Í∑∏Î¶¨Í∏∞
        function drawHandLandmarks(results) {
            const canvas = document.getElementById('canvasOverlay');
            const video = document.getElementById('videoElement');
            const ctx = canvas.getContext('2d');
            
            canvas.width = video.videoWidth || video.offsetWidth;
            canvas.height = video.videoHeight || video.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const handColor = index === 0 ? '#00ff00' : '#ff6600';
                    
                    ctx.strokeStyle = handColor;
                    ctx.lineWidth = 2;
                    
                    const connections = [
                        [0,1],[1,2],[2,3],[3,4],
                        [0,5],[5,6],[6,7],[7,8],
                        [0,9],[9,10],[10,11],[11,12],
                        [0,13],[13,14],[14,15],[15,16],
                        [0,17],[17,18],[18,19],[19,20],
                        [5,9],[9,13],[13,17]
                    ];
                    
                    connections.forEach(([start, end]) => {
                        const startPoint = landmarks[start];
                        const endPoint = landmarks[end];
                        
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x * canvas.width, startPoint.y * canvas.height);
                        ctx.lineTo(endPoint.x * canvas.width, endPoint.y * canvas.height);
                        ctx.stroke();
                    });
                    
                    landmarks.forEach(point => {
                        const x = point.x * canvas.width;
                        const y = point.y * canvas.height;
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.fillStyle = handColor;
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });
            }
        }

        // Ïπ¥Î©îÎùº ÏãúÏûë
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const video = document.getElementById('videoElement');
                video.srcObject = stream;
                
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play().then(resolve);
                    };
                });
                
                return true;
            } catch (error) {
                console.error('Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïò§Î•ò:', error);
                document.getElementById('status').textContent = 'Ïπ¥Î©îÎùº Ï†ëÍ∑º Ïã§Ìå®';
                document.getElementById('status').className = 'status error';
                return false;
            }
        }

        // Ïπ¥Î©îÎùº ÏãúÏûë/Ï§ëÏßÄ
        async function startDetection() {
            const startBtn = document.getElementById('startBtn');
            const recordBtn = document.getElementById('recordBtn');
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (!isDetecting) {
                const cameraReady = await startCamera();
                if (cameraReady) {
                    const video = document.getElementById('videoElement');
                    
                    const processFrame = async () => {
                        if (isDetecting && video.readyState >= 2) {
                            await hands.send({ image: video });
                        }
                        if (isDetecting) {
                            requestAnimationFrame(processFrame);
                        }
                    };
                    
                    isDetecting = true;
                    startBtn.textContent = 'Ïπ¥Î©îÎùº Ï§ëÏßÄ';
                    startBtn.classList.add('danger');
                    recordBtn.disabled = false;
                    recognitionBtn.disabled = false;
                    status.textContent = 'Ï§ÄÎπÑ ÏôÑÎ£å';
                    status.className = 'status ready';
                    
                    processFrame();
                }
            } else {
                isDetecting = false;
                isRecognizing = false;
                startBtn.textContent = 'Ïπ¥Î©îÎùº ÏãúÏûë';
                startBtn.classList.remove('danger');
                recordBtn.disabled = true;
                recognitionBtn.disabled = true;
                recognitionBtn.textContent = 'Ïù∏Ïãù Î™®Îìú';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'Ïπ¥Î©îÎùº Ï§ëÏßÄÎê®';
                status.className = 'status';
                
                const video = document.getElementById('videoElement');
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
            }
        }

        // ÎÖπÌôî ÏãúÏûë/Ï§ëÏßÄ
        function toggleRecording() {
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            if (!isRecording) {
                const word = wordInput.value.trim();
                if (!word) {
                    alert('ÌïôÏäµÌï† ÏàòÏñ¥ Îã®Ïñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî');
                    return;
                }
                
                // ÎÖπÌôî ÏãúÏûë
                isRecording = true;
                currentRecording = {
                    word: word,
                    features: [],
                    landmarks: [],
                    startTime: Date.now()
                };
                
                recordBtn.textContent = 'ÎÖπÌôî Ï§ëÏßÄ (3Ï¥à)';
                recordBtn.classList.add('recording-indicator');
                status.textContent = `"${word}" ÎÖπÌôî Ï§ë...`;
                status.className = 'status recording';
                wordInput.disabled = true;
                
                // 3Ï¥à ÎÖπÌôî ÏßÑÌñâÎ•† ÌëúÏãú
                let progress = 0;
                recordingInterval = setInterval(() => {
                    progress += 10;
                    progressBar.style.width = `${progress}%`;
                    
                    if (progress >= 100) {
                        clearInterval(recordingInterval);
                        stopRecording();
                    }
                }, 300);
                
            } else {
                stopRecording();
            }
        }

        // ÎÖπÌôî Ï§ëÏßÄ Î∞è ÌÅ¥ÎùºÏö∞Îìú Ï†ÄÏû•
        async function stopRecording() {
            if (recordingInterval) {
                clearInterval(recordingInterval);
            }
            
            isRecording = false;
            const recordBtn = document.getElementById('recordBtn');
            const wordInput = document.getElementById('wordInput');
            const status = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            recordBtn.textContent = 'ÎÖπÌôî ÏãúÏûë';
            recordBtn.classList.remove('recording-indicator');
            wordInput.disabled = false;
            progressBar.style.width = '0%';
            
            if (currentRecording && currentRecording.features.length > 0) {
                // ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
                const signData = {
                    features: currentRecording.features,
                    landmarks: currentRecording.landmarks,
                    timestamp: Date.now(),
                    fromCloud: false
                };
                
                trainedSigns[currentRecording.word] = signData;
                
                // Î°úÏª¨ Ï†ÄÏû•
                saveToLocalStorage();
                
                // ÌÅ¥ÎùºÏö∞Îìú ÏûêÎèô Ï†ÄÏû•
                const cloudSaved = await saveToCloudAuto(currentRecording.word, signData);
                
                if (cloudSaved) {
                    trainedSigns[currentRecording.word].fromCloud = true;
                    status.textContent = `"${currentRecording.word}" ÌïôÏäµ ÏôÑÎ£å! (ÌÅ¥ÎùºÏö∞Îìú Ï†ÄÏû•Îê®)`;
                    status.className = 'status cloud';
                } else {
                    status.textContent = `"${currentRecording.word}" ÌïôÏäµ ÏôÑÎ£å! (Î°úÏª¨ Ï†ÄÏû•Îê®)`;
                    status.className = 'status ready';
                }
                
                updateTrainedWordsList();
                
                // ÏûÖÎ†• ÌïÑÎìú Ï¥àÍ∏∞Ìôî
                wordInput.value = '';
            } else {
                status.textContent = 'ÎÖπÌôî Ïã§Ìå® - ÏÜêÏù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏùå';
                status.className = 'status error';
            }
            
            currentRecording = null;
        }

        // Ïù∏Ïãù Î™®Îìú ÌÜ†Í∏Ä
        function toggleRecognition() {
            const recognitionBtn = document.getElementById('recognitionBtn');
            const status = document.getElementById('status');
            
            if (Object.keys(trainedSigns).length === 0) {
                alert('Î®ºÏ†Ä ÏàòÏñ¥Î•º ÌïôÏäµÏãúÏºúÏ£ºÏÑ∏Ïöî!');
                return;
            }
            
            isRecognizing = !isRecognizing;
            
            if (isRecognizing) {
                recognitionBtn.textContent = 'Ïù∏Ïãù Ï§ëÏßÄ';
                recognitionBtn.classList.add('danger');
                status.textContent = 'Ïù∏Ïãù Î™®Îìú ÌôúÏÑ±Ìôî';
                status.className = 'status ready';
                recentFrames = [];
            } else {
                recognitionBtn.textContent = 'Ïù∏Ïãù Î™®Îìú';
                recognitionBtn.classList.remove('danger');
                status.textContent = 'Ïù∏Ïãù Î™®Îìú ÎπÑÌôúÏÑ±Ìôî';
                status.className = 'status';
                document.getElementById('currentSign').textContent = 'ÎåÄÍ∏∞ Ï§ë...';
                document.getElementById('confidence').textContent = 'Ïã†Î¢∞ÎèÑ: 0%';
            }
        }

        // ÌïôÏäµÎêú Îã®Ïñ¥ Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
        function updateTrainedWordsList() {
            const listElement = document.getElementById('trainedWordsList');
            const words = Object.keys(trainedSigns);
            
            if (words.length === 0) {
                listElement.innerHTML = '<div class="empty-message">ÌïôÏäµÎêú ÏàòÏñ¥Í∞Ä ÏóÜÏäµÎãàÎã§</div>';
                return;
            }
            
            listElement.innerHTML = '';
            words.forEach(word => {
                const item = document.createElement('div');
                item.className = 'trained-word-item';
                const isFromCloud = trainedSigns[word].fromCloud;
                item.innerHTML = `
                    <span>${word}${isFromCloud ? '<span class="cloud-indicator">‚òÅÔ∏è</span>' : ''}</span>
                    <button class="remove-btn" onclick="removeTrainedWord('${word}')">ÏÇ≠Ï†ú</button>
                `;
                listElement.appendChild(item);
            });
        }

        // ÌïôÏäµÎêú Îã®Ïñ¥ ÏÇ≠Ï†ú
        async function removeTrainedWord(word) {
            if (confirm(`"${word}" ÏàòÏñ¥Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                const wasFromCloud = trainedSigns[word].fromCloud;
                
                delete trainedSigns[word];
                updateTrainedWordsList();
                saveToLocalStorage();
                
                // ÌÅ¥ÎùºÏö∞ÎìúÏóêÏÑúÎèÑ ÏÇ≠Ï†ú
                if (wasFromCloud) {
                    await removeFromCloud(word);
                }
            }
        }

        // Ïù∏ÏãùÎêú Îã®Ïñ¥ Ï∂îÍ∞Ä
        let lastRecognizedWord = '';
        let lastRecognizedTime = 0;
        
        function addRecognizedWord(word) {
            const now = Date.now();
            
            if (word === lastRecognizedWord && now - lastRecognizedTime < 2000) {
                return;
            }
            
            lastRecognizedWord = word;
            lastRecognizedTime = now;
            
            const wordData = {
                text: word,
                timestamp: new Date(),
                id: Date.now()
            };
            
            recognizedWords.push(wordData);
            updateRecognizedWordsList();
        }

        // Ïù∏ÏãùÎêú Îã®Ïñ¥ Î™©Î°ù ÏóÖÎç∞Ïù¥Ìä∏
        function updateRecognizedWordsList() {
            const listElement = document.getElementById('recognizedWordsList');
            
            if (recognizedWords.length === 0) {
                listElement.innerHTML = '<div class="empty-message">Ïù∏ÏãùÎêú Îã®Ïñ¥Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§</div>';
                return;
            }
            
            listElement.innerHTML = '';
            
            recognizedWords.slice().reverse().forEach(wordData => {
                const item = document.createElement('div');
                item.className = 'word-item';
                item.innerHTML = `
                    <div>
                        <div class="word-text">${wordData.text}</div>
                        <div class="word-time">${formatTime(wordData.timestamp)}</div>
                    </div>
                    <button class="remove-btn" onclick="removeRecognizedWord(${wordData.id})">ÏÇ≠Ï†ú</button>
                `;
                listElement.appendChild(item);
            });
        }

        // Ïù∏ÏãùÎêú Îã®Ïñ¥ ÏÇ≠Ï†ú
        function removeRecognizedWord(id) {
            recognizedWords = recognizedWords.filter(word => word.id !== id);
            updateRecognizedWordsList();
        }

        // Ïù∏Ïãù Í∏∞Î°ù Ï†ÑÏ≤¥ ÏÇ≠Ï†ú
        function clearRecognizedWords() {
            if (recognizedWords.length === 0) return;
            
            if (confirm('Î™®Îì† Ïù∏Ïãù Í∏∞Î°ùÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                recognizedWords = [];
                updateRecognizedWordsList();
                document.getElementById('currentText').textContent = 'ÏàòÏñ¥Î•º ÌïôÏäµÏãúÌÇ® ÌõÑ Ïù∏Ïãù Î™®ÎìúÏóêÏÑú\nÏã§ÏãúÍ∞Ñ Ïù∏Ïãù Í≤∞Í≥ºÍ∞Ä ÌëúÏãúÎê©ÎãàÎã§';
                document.getElementById('currentText').style.color = '#888';
            }
        }

        // ÏãúÍ∞Ñ Ìè¨Îß∑ÌåÖ
        function formatTime(timestamp) {
            const now = new Date();
            const time = new Date(timestamp);
            const diff = now - time;
            
            if (diff < 60000) {
                return 'Î∞©Í∏à Ï†Ñ';
            } else if (diff < 3600000) {
                return `${Math.floor(diff / 60000)}Î∂Ñ Ï†Ñ`;
            } else {
                return time.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
            }
        }

        // LocalStorageÏóê Ï†ÄÏû•
        function saveToLocalStorage() {
            try {
                const data = {
                    trainedSigns: {},
                    savedAt: Date.now()
                };
                
                for (const [word, signData] of Object.entries(trainedSigns)) {
                    data.trainedSigns[word] = {
                        features: signData.features,
                        timestamp: signData.timestamp,
                        fromCloud: signData.fromCloud || false
                    };
                }
                
                localStorage.setItem('signLanguageData', JSON.stringify(data));
                console.log('Î°úÏª¨ Ï†ÄÏû• ÏôÑÎ£å');
            } catch (error) {
                console.error('Î°úÏª¨ Ï†ÄÏû• Ïò§Î•ò:', error);
            }
        }

        // LocalStorageÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('signLanguageData');
                if (saved) {
                    const data = JSON.parse(saved);
                    trainedSigns = data.trainedSigns || {};
                    updateTrainedWordsList();
                    console.log(`${Object.keys(trainedSigns).length}Í∞úÏùò ÏàòÏñ¥Î•º Î°úÏª¨ÏóêÏÑú Î∂àÎü¨ÏôîÏäµÎãàÎã§`);
                }
            } catch (error) {
                console.error('Î°úÏª¨ Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò:', error);
            }
        }

        // Ï¥àÍ∏∞Ìôî
        window.addEventListener('load', async () => {
            console.log('ÏàòÏñ¥ ÌïôÏäµ Î∞è Ïù∏Ïãù ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî');
            
            const status = document.getElementById('status');
            status.textContent = 'Supabase Ïó∞Í≤∞ Ï§ë...';
            status.className = 'status cloud';
            
            // Supabase Ï¥àÍ∏∞Ìôî
            initializeSupabase();
            
            // MediaPipe Î°úÎî© ÎåÄÍ∏∞
            setTimeout(async () => {
                if (typeof Hands !== 'undefined') {
                    initializeHands();
                    
                    // ÌÅ¥ÎùºÏö∞Îìú ÎòêÎäî Î°úÏª¨ÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞
                    await loadFromCloudAuto();
                    
                    status.textContent = isSupabaseEnabled ? 
                        'ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å (ÌÅ¥ÎùºÏö∞Îìú Ïó∞Í≤∞Îê®)' : 
                        'ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å (Î°úÏª¨ Î™®Îìú)';
                    status.className = 'status ready';
                } else {
                    status.textContent = 'MediaPipe Î°úÎî© Ïã§Ìå®';
                    status.className = 'status error';
                }
            }, 2000);
        });

        // ÌéòÏù¥ÏßÄ Îñ†ÎÇ† Îïå ÏûêÎèô Ï†ÄÏû•
        window.addEventListener('beforeunload', () => {
            if (Object.keys(trainedSigns).length > 0) {
                saveToLocalStorage();
            }
        });
    </script>
</body>
</html>


